<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>School Payment Management System</title>
    <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #4f46e5;
            --primary-dark: #4338ca;
            --secondary: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-light: #64748b;
            --border: #e2e8f0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: var(--text);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: var(--card-bg);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            animation: slideDown 0.5s ease-out;
        }

        .header h1 {
            color: var(--primary);
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .nav-tabs {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .nav-tab {
            padding: 12px 24px;
            background: var(--bg);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-light);
            transition: all 0.3s ease;
        }

        .nav-tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .nav-tab.active {
            background: var(--primary);
            color: white;
        }

        .section {
            display: none;
            background: var(--card-bg);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            animation: fadeIn 0.4s ease-out;
        }

        .section.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text);
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--border);
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-block;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
        }

        .btn-success {
            background: var(--secondary);
            color: white;
        }

        .btn-success:hover {
            background: #059669;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: var(--text-light);
            color: white;
        }

        .btn-secondary:hover {
            background: #475569;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
            transform: translateY(-2px);
        }

        .btn-warning {
            background: var(--warning);
            color: white;
        }

        .btn-warning:hover {
            background: #d97706;
            transform: translateY(-2px);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .card {
            background: var(--bg);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid var(--border);
            transition: all 0.3s ease;
            animation: slideUp 0.4s ease-out;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            border-color: var(--primary);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .card-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--primary);
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        .card-body {
            color: var(--text-light);
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        .badge-success {
            background: #d1fae5;
            color: #065f46;
        }

        .badge-danger {
            background: #fee2e2;
            color: #991b1b;
        }

        .badge-warning {
            background: #fef3c7;
            color: #92400e;
        }

        /* Yearly month view */
        .year-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .year-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .year-selector button {
            padding: 4px 10px;
            border-radius: 999px;
            border: none;
            background: var(--bg);
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-light);
            transition: all 0.2s ease;
        }

        .year-selector button:hover {
            background: var(--primary);
            color: white;
        }

        .year-label {
            font-weight: 600;
            color: var(--text);
        }

        .month-grid {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .month-cell {
            padding: 10px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--bg);
            font-size: 0.9rem;
        }

        .month-name {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .month-status {
            font-size: 0.8rem;
        }

        .month-paid {
            background: #dcfce7;
            border-color: #22c55e;
        }

        .month-unpaid {
            background: #fee2e2;
            border-color: #ef4444;
        }

        .badge-month {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 999px;
            background: #fee2e2;
            color: #b91c1c;
            font-size: 0.8rem;
            margin: 2px;
        }

        .debt-viewer {
            background: var(--bg);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .debt-student-card {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            max-width: 600px;
            width: 100%;
            animation: scaleIn 0.4s ease-out;
        }

        .debt-student-name {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 20px;
        }

        .debt-amount {
            font-size: 3rem;
            font-weight: 700;
            color: var(--danger);
            margin: 20px 0;
        }

        .debt-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
            text-align: left;
        }

        .debt-info-item {
            padding: 15px;
            background: var(--bg);
            border-radius: 10px;
        }

        .debt-info-label {
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 5px;
        }

        .debt-info-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text);
        }

        .navigation-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            padding: 25px;
            border-radius: 15px;
            color: white;
            animation: slideUp 0.4s ease-out;
        }

        .stat-card.success {
            background: linear-gradient(135deg, var(--secondary) 0%, #059669 100%);
        }

        .stat-card.danger {
            background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
        }

        .stat-card.warning {
            background: linear-gradient(135deg, var(--warning) 0%, #d97706 100%);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .alert {
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            animation: slideDown 0.3s ease-out;
        }

        .alert-success {
            background: #d1fae5;
            color: #065f46;
            border-left: 4px solid var(--secondary);
        }

        .alert-error {
            background: #fee2e2;
            color: #991b1b;
            border-left: 4px solid var(--danger);
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-light);
        }

        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .parent-info {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .parent-badge {
            background: #e0e7ff;
            color: var(--primary);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.85rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè´ School Payment Management</h1>
            <p style="color: var(--text-light); margin-top: 10px;">Manage students, groups, and payments efficiently</p>
            <div class="nav-tabs">
                <button class="nav-tab active" onclick="showSection('dashboard')">Dashboard</button>
                <button class="nav-tab" onclick="showSection('students')">Students</button>
                <button class="nav-tab" onclick="showSection('groups')">Groups</button>
                <button class="nav-tab" onclick="showSection('records')">Records</button>
                <button class="nav-tab" onclick="showSection('pledges')">Pledges</button>
                <button class="nav-tab" onclick="showSection('pledgeRecords')">Pledge Records</button>
                <button class="nav-tab" onclick="showSection('pledgeDebt')">Pledge Debt View</button>
                <button class="nav-tab" onclick="showSection('debt')">Debt View</button>
                <button class="nav-tab" onclick="showSection('systemRules')">System Rules</button>
                <button class="nav-tab" onclick="showSection('settings')">Settings</button>
            </div>
        </div>

        <!-- Dashboard Section -->
        <div id="dashboard" class="section active">
            <h2 style="margin-bottom: 20px;">üìä Dashboard</h2>
            <div class="stats-grid" id="statsGrid">
                <div class="stat-card">
                    <div class="stat-value" id="totalStudents">0</div>
                    <div class="stat-label">Total Students</div>
                </div>
                <div class="stat-card success">
                    <div class="stat-value" id="paidStudents">0</div>
                    <div class="stat-label">Paid Students</div>
                </div>
                <div class="stat-card danger">
                    <div class="stat-value" id="debtStudents">0</div>
                    <div class="stat-label">In Debt</div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-value" id="totalGroups">0</div>
                    <div class="stat-label">Total Groups</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalPledges">0</div>
                    <div class="stat-label">Total Pledges</div>
                </div>
                <div class="stat-card danger">
                    <div class="stat-value" id="inDangerPledges">0</div>
                    <div class="stat-label">Pledges In Danger</div>
                </div>
                <div class="stat-card danger">
                    <div class="stat-value" id="overduePledges">0</div>
                    <div class="stat-label">Overdue Pledges</div>
                </div>
            </div>
            <div id="dashboardContent"></div>
        </div>

        <!-- Students Section -->
        <div id="students" class="section">
            <h2 style="margin-bottom: 20px;">üë• Students</h2>
            <div id="studentAlert"></div>
            <form id="studentForm" onsubmit="addStudent(event)">
                <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));">
                    <div class="form-group">
                        <label>Student Name *</label>
                        <input type="text" id="studentName" required>
                    </div>
                    <div class="form-group">
                        <label>Parent Name (optional)</label>
                        <input type="text" id="parentName">
                    </div>
                    <div class="form-group">
                        <label>Parent Phone (optional)</label>
                        <input type="tel" id="parentPhone">
                    </div>
                    <div class="form-group">
                        <label>Relationship (optional)</label>
                        <select id="parentRelationship">
                            <option value="">Select...</option>
                            <option value="Mom">Mom</option>
                            <option value="Dad">Dad</option>
                            <option value="Guardian">Guardian</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>
                </div>
                <button type="submit" class="btn btn-primary">‚ûï Add Student</button>
                <button type="button" class="btn btn-secondary" onclick="toggleUploadPanel()" style="margin-left: 10px;">üìÑ Upload File</button>
            </form>
            <!-- Bulk Import from File -->
            <div id="uploadPanel" class="card" style="margin-top: 25px; background: #f0f9ff; border: 2px dashed var(--primary); display: none;">
                <h3 style="margin-bottom: 15px; color: var(--primary);">üìÑ Bulk Import Students from File</h3>
                <p style="color: var(--text-light); margin-bottom: 15px; font-size: 0.9rem;">Upload a PDF, Word document, or spreadsheet to extract student names and parent information.</p>
                <div class="form-group">
                    <input type="file" id="fileUpload" accept=".pdf,.doc,.docx,.xls,.xlsx,.txt" style="padding: 8px; border: 2px solid var(--border); border-radius: 8px; width: 100%;">
                </div>
                <button class="btn btn-primary" onclick="handleFileUpload()" style="width: 100%;">üìÑ Extract Students</button>
                <div id="fileUploadStatus" style="margin-top: 10px; font-size: 0.9rem;"></div>
            </div>
            <!-- Preview and Edit Extracted Students -->
            <div id="extractedStudentsPreview" style="margin-top: 20px; display: none;"></div>
            <!-- Student search -->
            <div class="form-group" style="margin-top: 25px; max-width: 400px;">
                <label>Search Students</label>
                <input type="text" id="studentSearch" placeholder="Search by student or parent name..." oninput="onStudentSearchChange(event)">
            </div>
            <!-- Yearly view panel for selected student -->
            <div id="studentYearPanel" class="card" style="margin-top: 20px; display: none;"></div>
            <div class="grid" id="studentsList" style="margin-top: 20px;"></div>
        </div>

        <!-- Groups Section -->
        <div id="groups" class="section">
            <h2 style="margin-bottom: 20px;">üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Groups</h2>
            <div id="groupAlert"></div>
            <form id="groupForm" onsubmit="createGroup(event)" style="margin-bottom: 30px;">
                <div class="form-group" style="max-width: 400px;">
                    <label>Group Name *</label>
                    <input type="text" id="groupName" required>
                </div>
                <button type="submit" class="btn btn-primary">‚ûï Create Group</button>
            </form>
            <div class="grid" id="groupsList"></div>
        </div>

        <!-- Records Section -->
        <div id="records" class="section">
            <h2 style="margin-bottom: 20px;">üìö Records</h2>
            <div class="form-group" style="max-width: 400px;">
                <label>Search Students</label>
                <input type="text" id="recordSearch" placeholder="Search by student name..." oninput="onRecordSearchChange(event)">
            </div>
            <div class="grid" id="recordsStudentList" style="margin-top: 20px;"></div>
            <div id="recordDetails" class="card" style="margin-top: 20px; display: none;"></div>
        </div>

        <!-- Pledges Section -->
        <div id="pledges" class="section">
            <h2 style="margin-bottom: 20px;">ü§ù Pledges</h2>
            <div id="pledgeAlert"></div>
            <form id="pledgeForm" onsubmit="addPledge(event)" style="margin-bottom: 30px;">
                <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));">
                    <div class="form-group">
                        <label>Person Name *</label>
                        <input type="text" id="pledgeName" required>
                    </div>
                    <div class="form-group">
                        <label>Phone Number (optional)</label>
                        <input type="tel" id="pledgePhone">
                    </div>
                    <div class="form-group">
                        <label>Pledged Amount ($) *</label>
                        <input type="number" id="pledgeAmount" step="0.01" min="0" required>
                    </div>
                    <div class="form-group">
                        <label>Payment Schedule *</label>
                        <select id="pledgeSchedule" required onchange="updatePledgeDateOptions()">
                            <option value="">Select...</option>
                            <option value="byDate">By Specific Date</option>
                            <option value="recurring">Recurring Payment</option>
                            <option value="30">Over 30 Days</option>
                            <option value="60">Over 60 Days</option>
                            <option value="90">Over 90 Days</option>
                            <option value="120">Over 120 Days</option>
                            <option value="180">Over 180 Days</option>
                            <option value="365">Over 1 Year</option>
                        </select>
                    </div>
                    <div class="form-group" id="pledgeDateGroup" style="display: none;">
                        <label>Target Date *</label>
                        <input type="date" id="pledgeDate">
                    </div>
                    <div class="form-group" id="pledgeRecurringGroup" style="display: none;">
                        <label>Recurring Frequency *</label>
                        <select id="pledgeRecurring">
                            <option value="">Select...</option>
                            <option value="1">Every Day</option>
                            <option value="7">Every Week</option>
                            <option value="14">Every 2 Weeks</option>
                            <option value="30">Every Month</option>
                            <option value="60">Every 2 Months</option>
                            <option value="90">Every 3 Months</option>
                            <option value="180">Every 6 Months</option>
                            <option value="365">Every Year</option>
                        </select>
                    </div>
                </div>
                <button type="submit" class="btn btn-primary">‚ûï Add Pledge</button>
            </form>
            <!-- Yearly view panel for selected pledge -->
            <div id="pledgeYearPanel" class="card" style="margin-top: 20px; display: none;"></div>
            <div class="grid" id="pledgesList"></div>
        </div>

        <!-- Pledge Records Section -->
        <div id="pledgeRecords" class="section">
            <h2 style="margin-bottom: 20px;">üìã Pledge Records (Completed)</h2>
            <div class="form-group" style="max-width: 400px;">
                <label>Search Completed Pledges</label>
                <input type="text" id="pledgeRecordSearch" placeholder="Search by person name..." oninput="onPledgeRecordSearchChange(event)">
            </div>
            <div class="grid" id="pledgeRecordsList" style="margin-top: 20px;"></div>
        </div>

        <!-- Pledge Debt View Section -->
        <div id="pledgeDebt" class="section">
            <h2 style="margin-bottom: 20px;">‚ö†Ô∏è Pledges in Debt</h2>
            <div class="debt-viewer" id="pledgeDebtViewer">
                <div class="empty-state">
                    <div class="empty-state-icon">üí∞</div>
                    <h3>No pledges in debt!</h3>
                    <p>All pledges are up to date.</p>
                </div>
            </div>
        </div>

        <!-- Debt View Section -->
        <div id="debt" class="section">
            <h2 style="margin-bottom: 20px;">‚ö†Ô∏è Students in Debt</h2>
            <div class="debt-viewer" id="debtViewer">
                <div class="empty-state">
                    <div class="empty-state-icon">üí∞</div>
                    <h3>No students in debt!</h3>
                    <p>All students are up to date with their payments.</p>
                </div>
            </div>
        </div>

        <!-- System Rules Section -->
        <div id="systemRules" class="section">
            <h2 style="margin-bottom: 20px;">üìñ System Rules & Help</h2>
            <div class="card" style="margin-bottom: 20px;">
                <h3 style="margin-bottom: 15px; color: var(--primary);">üìö Table of Contents</h3>
                <ul style="padding-left: 20px; line-height: 2;">
                    <li><a href="#students-help" style="color: var(--primary); text-decoration: underline; cursor: pointer;">Students Management</a></li>
                    <li><a href="#groups-help" style="color: var(--primary); text-decoration: underline; cursor: pointer;">Groups</a></li>
                    <li><a href="#pledges-help" style="color: var(--primary); text-decoration: underline; cursor: pointer;">Pledges</a></li>
                    <li><a href="#payments-help" style="color: var(--primary); text-decoration: underline; cursor: pointer;">Payments & Debt</a></li>
                    <li><a href="#records-help" style="color: var(--primary); text-decoration: underline; cursor: pointer;">Records</a></li>
                </ul>
            </div>

            <div id="students-help" class="card" style="margin-bottom: 20px; scroll-margin-top: 20px;">
                <h3 style="margin-bottom: 15px; color: var(--primary);">üë®‚Äçüéì Students Management</h3>
                <div style="line-height: 1.8;">
                    <p><strong>Adding Students:</strong> Fill in the student's name and optionally add parent information (name, phone, relationship).</p>
                    <p><strong>Monthly Fee:</strong> Each student owes $100 per month starting from their creation date.</p>
                    <p><strong>Year View:</strong> Click on a student to see all months for a year, showing which are paid, unpaid, or partially paid. You can change the year using the navigation buttons.</p>
                    <p><strong>Overpayments:</strong> If a student pays more than they owe, the excess automatically applies to future months, reducing their future debt.</p>
                    <p><strong>Adding Debt:</strong> You can add extra charges/debt to students, which will appear in their records.</p>
                    <p><strong>Forgiving Debt:</strong> You can forgive a student's debt with an optional reason, which will be recorded.</p>
                    <p><strong>Bulk Import:</strong> Upload a PDF, Word document, or spreadsheet to extract student names and parent information using AI. Review and edit before accepting.</p>
                </div>
            </div>

            <div id="groups-help" class="card" style="margin-bottom: 20px; scroll-margin-top: 20px;">
                <h3 style="margin-bottom: 15px; color: var(--primary);">üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Groups</h3>
                <div style="line-height: 1.8;">
                    <p><strong>Creating Groups:</strong> Create groups to organize students. Each group shows the total debt from all members.</p>
                    <p><strong>Adding Students:</strong> Use the search to find students, then hold Ctrl (Windows) or Cmd (Mac) to select multiple students at once.</p>
                    <p><strong>Group Payments:</strong> Record a group payment that will be split equally among all group members. Each member's record will show their portion of the group payment.</p>
                    <p><strong>Removing Students:</strong> Click "Remove" next to a student's name to remove them from the group (does not delete the student).</p>
                </div>
            </div>

            <div id="pledges-help" class="card" style="margin-bottom: 20px; scroll-margin-top: 20px;">
                <h3 style="margin-bottom: 15px; color: var(--primary);">ü§ù Pledges</h3>
                <div style="line-height: 1.8;">
                    <p><strong>Pledge Types:</strong></p>
                    <ul style="padding-left: 20px; margin-top: 10px;">
                        <li><strong>By Date:</strong> Full amount due by a specific date. Starts in debt immediately.</li>
                        <li><strong>Recurring:</strong> Amount repeats at regular intervals (daily, weekly, monthly, etc.). Each period adds the full pledged amount.</li>
                        <li><strong>Over X Days:</strong> Total amount divided evenly over the specified number of days. Uses RPP (Recommended Payment Plan) for tracking.</li>
                    </ul>
                    <p style="margin-top: 15px;"><strong>RPP (Recommended Payment Plan):</strong> For "Over X Days" pledges, shows the daily payment amount and tracks debt based on how much should have been paid by now according to the plan.</p>
                    <p><strong>Pledge Status:</strong></p>
                    <ul style="padding-left: 20px; margin-top: 10px;">
                        <li><strong>Safe:</strong> Pledge is active and on track (not fully paid but not in danger).</li>
                        <li><strong>In Danger:</strong> According to RPP, they've missed about 50% of expected payments, or for recurring pledges, they've missed 1 payment period.</li>
                        <li><strong>Overdue:</strong> For "Over X Days" pledges, the period has ended but not fully paid. For recurring pledges, they've missed 2+ payment periods.</li>
                        <li><strong>Completed:</strong> Pledge is fully paid and completed.</li>
                    </ul>
                    <p style="margin-top: 15px;"><strong>Year View:</strong> Shows payment status over time. For weekly pledges, shows weeks. For daily, shows days. For monthly, shows months.</p>
                    <p><strong>Ending Pledges:</strong> For recurring pledges, you can manually end them to move them to records.</p>
                </div>
            </div>

            <div id="payments-help" class="card" style="margin-bottom: 20px; scroll-margin-top: 20px;">
                <h3 style="margin-bottom: 15px; color: var(--primary);">üíµ Payments & Debt</h3>
                <div style="line-height: 1.8;">
                    <p><strong>Recording Payments:</strong> When recording a payment, you can optionally specify the payment method (cash, check, online, etc.).</p>
                    <p><strong>Debt Calculation:</strong> Debt = Monthly fees + Additional charges - Payments - Forgiven amounts. Overpayments automatically apply to future months.</p>
                    <p><strong>Partial Payments:</strong> If a payment doesn't cover a full month, it shows as "Partial" and the remaining amount carries to the next month.</p>
                    <p><strong>Debt View:</strong> Navigate through students in debt one by one using arrow keys or buttons. Shows which months are missing payments.</p>
                    <p><strong>Pledge Debt View:</strong> Similar to student debt view, but for pledges. Shows pledges that are in debt.</p>
                </div>
            </div>

            <div id="records-help" class="card" style="margin-bottom: 20px; scroll-margin-top: 20px;">
                <h3 style="margin-bottom: 15px; color: var(--primary);">üìö Records</h3>
                <div style="line-height: 1.8;">
                    <p><strong>Student Records:</strong> View all payments, debt additions, and forgiveness for each student. Search by name to find students quickly.</p>
                    <p><strong>Download PDF:</strong> Download a complete record of a student's financial history as a PDF, including the date generated.</p>
                    <p><strong>Pledge Records:</strong> View completed pledges grouped by person name. Shows all transactions and can download as PDF.</p>
                    <p><strong>Group Payments:</strong> Group payments appear in each member's records showing their portion of the total group payment.</p>
                </div>
            </div>
        </div>

        <!-- Settings Section -->
        <div id="settings" class="section">
            <h2 style="margin-bottom: 20px;">‚öôÔ∏è Settings</h2>
            <p style="color: var(--text-light); margin-bottom: 20px;">Danger zone ‚Äì these actions cannot be undone.</p>
            <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));">
                <div class="card">
                    <h3 style="margin-bottom: 10px;">Clear All Data</h3>
                    <p style="color: var(--text-light); margin-bottom: 15px;">Delete all students, groups, payments, and forgiveness records.</p>
                    <button class="btn btn-danger" onclick="clearAllData()">üßπ Clear All Data</button>
                </div>
                <div class="card">
                    <h3 style="margin-bottom: 10px;">Clear All Debt & Records</h3>
                    <p style="color: var(--text-light); margin-bottom: 15px;">Forgive all past debt by resetting financial history from today.</p>
                    <button class="btn btn-danger" onclick="clearAllDebtAndRecords()">‚úÖ Clear All Debt & Records</button>
                </div>
                <div class="card">
                    <h3 style="margin-bottom: 10px;">Clear All Records Only</h3>
                    <p style="color: var(--text-light); margin-bottom: 15px;">Remove all payments and forgiveness logs but keep students and groups.</p>
                    <button class="btn btn-danger" onclick="clearAllRecordsOnly()">üóë Clear All Records</button>
                </div>
                <div class="card">
                    <h3 style="margin-bottom: 10px;">End All Active Pledges</h3>
                    <p style="color: var(--text-light); margin-bottom: 15px;">Mark all active pledges as completed and move them to records.</p>
                    <button class="btn btn-danger" onclick="endAllActivePledges()">üèÅ End All Pledges</button>
                </div>
                <div class="card">
                    <h3 style="margin-bottom: 10px;">Delete All Pledges</h3>
                    <p style="color: var(--text-light); margin-bottom: 15px;">Permanently delete all pledges and pledge records. This cannot be undone.</p>
                    <button class="btn btn-danger" onclick="deleteAllPledges()">üóë Delete All Pledges</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const UPSTASH_URL = "https://brief-piglet-43973.upstash.io";
        const UPSTASH_TOKEN = "AavFAAIncDE0MzMyYmY1ZTkwMWM0YzJjODIxYmI0Mjg4ZDcyNTk2NHAxNDM5NzM";
        const MONTHLY_FEE = 100;

        // Upstash Redis API functions
        async function redisGet(key) {
            try {
                const response = await fetch(`${UPSTASH_URL}/get/${encodeURIComponent(key)}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${UPSTASH_TOKEN}`
                    }
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                if (data.result === null || data.result === undefined) return null;
                // Handle string result (JSON stringified)
                if (typeof data.result === 'string') {
                    try {
                        return JSON.parse(data.result);
                    } catch (e) {
                        return data.result;
                    }
                }
                return data.result;
            } catch (error) {
                console.error('Redis GET error:', error);
                showAlert('studentAlert', 'Error loading data. Please refresh the page.', 'error');
                return null;
            }
        }

        async function redisSet(key, value) {
            try {
                const response = await fetch(`${UPSTASH_URL}/set/${encodeURIComponent(key)}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${UPSTASH_TOKEN}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(value)
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error('Redis SET error:', error);
                showAlert('studentAlert', 'Error saving data. Please try again.', 'error');
                return null;
            }
        }

        // Data management
        let cachedStudents = [];
        let cachedGroups = [];
        let studentSearchText = '';
        let recordSearchText = '';
        let selectedStudentForYear = null;
        let selectedYearForStudent = new Date().getFullYear();
        let debtViewYear = new Date().getFullYear();

        const MONTH_NAMES = [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ];
        async function getStudents() {
            const students = await redisGet('students') || [];
            cachedStudents = students;
            return students;
        }

        async function saveStudents(students) {
            cachedStudents = students;
            return await redisSet('students', students);
        }

        async function getGroups() {
            const groups = await redisGet('groups') || [];
            cachedGroups = groups;
            return groups;
        }

        async function saveGroups(groups) {
            cachedGroups = groups;
            return await redisSet('groups', groups);
        }

        // Navigation
        function showSection(sectionId) {
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));

            const section = document.getElementById(sectionId);
            if (section) section.classList.add('active');

            // Activate the corresponding tab based on its onclick attribute
            document.querySelectorAll('.nav-tab').forEach(btn => {
                const onclick = btn.getAttribute('onclick') || '';
                if (onclick.includes(`'${sectionId}'`)) {
                    btn.classList.add('active');
                }
            });
            
            if (sectionId === 'dashboard') {
                loadDashboard();
            } else if (sectionId === 'students') {
                loadStudents();
            } else if (sectionId === 'groups') {
                loadGroups();
            } else if (sectionId === 'records') {
                loadRecordsSection();
            } else if (sectionId === 'debt') {
                loadDebtView();
            } else if (sectionId === 'pledges') {
                loadPledges();
            } else if (sectionId === 'pledgeRecords') {
                loadPledgeRecords();
            } else if (sectionId === 'pledgeDebt') {
                loadPledgeDebtView();
            } else if (sectionId === 'systemRules') {
                // System Rules section doesn't need loading
            } else if (sectionId === 'settings') {
                // nothing dynamic needed yet
            }
        }

        // Add Student
        async function addStudent(e) {
            e.preventDefault();
            const name = document.getElementById('studentName').value;
            const parentName = document.getElementById('parentName').value;
            const parentPhone = document.getElementById('parentPhone').value;
            const relationship = document.getElementById('parentRelationship').value;

            const students = await getStudents();
            const newStudent = {
                id: Date.now().toString(),
                name: name,
                parent: {
                    name: parentName,
                    phone: parentPhone,
                    relationship: relationship
                },
                groups: [],
                payments: [],
                forgivenRecords: [],
                chargeRecords: [],
                createdAt: new Date().toISOString()
            };

            students.push(newStudent);
            await saveStudents(students);
            
            document.getElementById('studentForm').reset();
            showAlert('studentAlert', 'Student added successfully!', 'success');
            loadStudents();
            loadDashboard();
        }

        // Create Group
        async function createGroup(e) {
            e.preventDefault();
            const name = document.getElementById('groupName').value;

            const groups = await getGroups();
            const newGroup = {
                id: Date.now().toString(),
                name: name,
                studentIds: [],
                createdAt: new Date().toISOString()
            };

            groups.push(newGroup);
            await saveGroups(groups);
            
            document.getElementById('groupForm').reset();
            showAlert('groupAlert', 'Group created successfully!', 'success');
            loadGroups();
            loadDashboard();
        }

        // Add multiple Students to Group
        async function addStudentsToGroup(groupId, studentIds) {
            if (!studentIds || studentIds.length === 0) return;

            const groups = await getGroups();
            const group = groups.find(g => g.id === groupId);
            if (!group) return;

            const students = await getStudents();

            studentIds.forEach(studentId => {
                if (!group.studentIds.includes(studentId)) {
                    group.studentIds.push(studentId);
                }
                const student = students.find(s => s.id === studentId);
                if (student) {
                    if (!Array.isArray(student.groups)) {
                        student.groups = [];
                    }
                    if (!student.groups.includes(groupId)) {
                        student.groups.push(groupId);
                    }
                }
            });

            await saveGroups(groups);
            await saveStudents(students);

            loadGroups();
            loadStudents();
        }

        function handleAddStudentsToGroup(groupId) {
            const selectEl = document.getElementById(`addStudent_${groupId}`);
            if (!selectEl) return;
            const selectedIds = Array.from(selectEl.selectedOptions).map(o => o.value).filter(Boolean);
            addStudentsToGroup(groupId, selectedIds);
        }

        function onGroupStudentSearchChange(groupId, e) {
            const searchText = e.target.value.toLowerCase();
            const selectEl = document.getElementById(`addStudent_${groupId}`);
            if (!selectEl) return;

            // Rebuild options from cachedStudents based on current group membership and search text
            const group = cachedGroups.find(g => g.id === groupId);
            if (!group) return;

            const availableStudents = cachedStudents.filter(s => !group.studentIds.includes(s.id));
            const filtered = searchText
                ? availableStudents.filter(s => s.name.toLowerCase().includes(searchText))
                : availableStudents;

            selectEl.innerHTML = filtered.map(s => `<option value="${s.id}">${s.name}</option>`).join('');
        }

        // Record Payment
        async function recordPayment(studentId, amount, month, year, method) {
            const students = await getStudents();
            const student = students.find(s => s.id === studentId);
            if (student) {
                const payment = {
                    id: Date.now().toString(),
                    amount: parseFloat(amount),
                    month: month,
                    year: year,
                    method: method || '',
                    date: new Date().toISOString()
                };
                student.payments.push(payment);
                await saveStudents(students);
                loadDashboard();
                loadDebtView();
                showAlert('studentAlert', 'Payment recorded successfully!', 'success');
            }
        }

        // Calculate Debt (monthly fees + added charges - payments - forgiven)
        function calculateDebt(student) {
            const now = new Date();
            const currentMonth = now.getMonth();
            const currentYear = now.getFullYear();
            
            // Calculate months since creation
            const created = new Date(student.createdAt);
            const monthsSinceCreation = (currentYear - created.getFullYear()) * 12 + 
                                       (currentMonth - created.getMonth()) + 1;
            
            const baseOwed = monthsSinceCreation * MONTHLY_FEE;
            const addedCharges = (Array.isArray(student.chargeRecords) ? student.chargeRecords : []).reduce((sum, c) => sum + (c.amount || 0), 0);
            const totalOwed = baseOwed + addedCharges;
            const totalPaid = (Array.isArray(student.payments) ? student.payments : []).reduce((sum, p) => sum + (p.amount || 0), 0);
            const totalForgiven = (Array.isArray(student.forgivenRecords) ? student.forgivenRecords : []).reduce((sum, f) => sum + (f.amount || 0), 0);
            
            return Math.max(0, totalOwed - totalPaid - totalForgiven);
        }

        // Load Dashboard
        async function loadDashboard() {
            const students = await getStudents();
            const groups = await getGroups();
            const pledges = await getPledges();
            
            const paidStudents = students.filter(s => calculateDebt(s) === 0).length;
            const debtStudents = students.filter(s => calculateDebt(s) > 0).length;
            
            const activePledges = pledges.filter(p => !p.completed);
            const now = new Date();
            
            // Calculate overdue pledges (debt > 50% of expected debt scaled to time)
            const inDangerPledges = activePledges.filter(pledge => {
                const status = getPledgeStatus(pledge);
                return status === 'danger';
            }).length;
            
            const overduePledges = activePledges.filter(pledge => {
                const status = getPledgeStatus(pledge);
                return status === 'overdue';
            }).length;
            
            document.getElementById('totalStudents').textContent = students.length;
            document.getElementById('paidStudents').textContent = paidStudents;
            document.getElementById('debtStudents').textContent = debtStudents;
            document.getElementById('totalGroups').textContent = groups.length;
            document.getElementById('totalPledges').textContent = activePledges.length;
            document.getElementById('inDangerPledges').textContent = inDangerPledges;
            document.getElementById('overduePledges').textContent = overduePledges;
        }

        function onStudentSearchChange(e) {
            studentSearchText = e.target.value.toLowerCase();
            renderStudents(cachedStudents, cachedGroups);
        }

        // Load Students
        async function loadStudents() {
            const students = await getStudents();
            const groups = await getGroups();
            cachedStudents = students;
            cachedGroups = groups;
            renderStudents(students, groups);
        }

        function renderStudents(students, groups) {
            const container = document.getElementById('studentsList');
            
            if (students.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üë•</div><h3>No students yet</h3><p>Add your first student to get started!</p></div>';
                return;
            }

            const filteredStudents = studentSearchText
                ? students.filter(s => {
                    const parentName = (s.parent && s.parent.name) ? s.parent.name : '';
                    return s.name.toLowerCase().includes(studentSearchText) ||
                           parentName.toLowerCase().includes(studentSearchText);
                  })
                : students;

            if (filteredStudents.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üîç</div><h3>No students match your search</h3><p>Try a different name.</p></div>';
                return;
            }
            
            container.innerHTML = filteredStudents.map(student => {
                const debt = calculateDebt(student);
                const studentGroups = groups.filter(g => student.groups.includes(g.id));
                const hasParentInfo = student.parent && (student.parent.name || student.parent.phone || student.parent.relationship);
                
                return `
                    <div class="card">
                        <div class="card-header">
                            <div class="card-title" style="word-break: break-word;">${student.name}</div>
                            ${debt > 0 ? '<span class="badge badge-danger">$' + debt + ' debt</span>' : '<span class="badge badge-success">Paid</span>'}
                        </div>
                        <div class="card-body">
                            ${hasParentInfo ? `
                            <div class="parent-info">
                                ${student.parent.relationship ? `<span class="parent-badge">${student.parent.relationship}</span>` : ''}
                                ${student.parent.name ? `<span>${student.parent.name}</span>` : ''}
                            </div>
                            ${student.parent.phone ? `<div style="margin-top: 10px; color: var(--text-light);">üìû ${student.parent.phone}</div>` : ''}
                            ` : '<div style="color: var(--text-light); font-size: 0.9rem;">No parent info provided.</div>'}
                            ${studentGroups.length > 0 ? '<div style="margin-top: 10px;"><strong>Groups:</strong> ' + studentGroups.map(g => g.name).join(', ') + '</div>' : ''}
                            <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                                <button class="btn btn-success" onclick="showPaymentModal('${student.id}')" style="font-size: 0.9rem; padding: 8px 16px;">üíµ Record Payment</button>
                                <button class="btn btn-primary" onclick="showAddToGroupModal('${student.id}')" style="font-size: 0.9rem; padding: 8px 16px;">‚ûï Add to Group</button>
                                <button class="btn btn-primary" onclick="showStudentYear('${student.id}')" style="font-size: 0.9rem; padding: 8px 16px;">üìÜ Year View</button>
                                <button class="btn btn-success" onclick="forgiveDebt('${student.id}')" style="font-size: 0.9rem; padding: 8px 16px;">‚úÖ Forgive Debt</button>
                                <button class="btn btn-primary" onclick="addDebt('${student.id}')" style="font-size: 0.9rem; padding: 8px 16px;">‚ûï Add Debt</button>
                                <button class="btn btn-danger" onclick="deleteStudent('${student.id}')" style="font-size: 0.9rem; padding: 8px 16px;">üóë Delete</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Load Groups
        async function loadGroups() {
            const groups = await getGroups();
            const students = await getStudents();
            cachedGroups = groups;
            cachedStudents = students;
            const container = document.getElementById('groupsList');
            
            if (groups.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üë®‚Äçüë©‚Äçüëß‚Äçüë¶</div><h3>No groups yet</h3><p>Create your first group to organize students!</p></div>';
                return;
            }
            
            container.innerHTML = groups.map(group => {
                const groupStudents = students.filter(s => group.studentIds.includes(s.id));
                const availableStudents = students.filter(s => !group.studentIds.includes(s.id));
                const groupTotalDebt = groupStudents.reduce((sum, s) => sum + calculateDebt(s), 0);
                
                return `
                    <div class="card">
                        <div class="card-header">
                            <div>
                                <div class="card-title" style="word-break: break-word;">${group.name}</div>
                                <div style="margin-top:4px; font-size:0.9rem; color:var(--text-light);">
                                    ${groupStudents.length} student${groupStudents.length === 1 ? '' : 's'}
                                </div>
                            </div>
                            <div style="text-align:right;">
                                <div><span class="badge badge-danger">Debt: $${groupTotalDebt.toFixed(2)}</span></div>
                                <button class="btn btn-danger" onclick="deleteGroup('${group.id}')" style="margin-top:8px; padding:6px 12px; font-size:0.85rem;">üóë Delete Group</button>
                            </div>
                        </div>
                        <div class="card-body">
                            ${groupStudents.length > 0 ? 
                                `<div style="margin-bottom: 15px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                        <strong>Students:</strong>
                                        <button class="btn btn-success" onclick="recordGroupPayment('${group.id}')" style="padding:6px 12px;font-size:0.85rem;">üíµ Record Group Payment</button>
                                    </div>
                                    <ul style="margin-top: 10px; padding-left: 20px;">` + 
                                groupStudents.map(s => `<li style="display:flex;justify-content:space-between;align-items:center;gap:8px;"><span>${s.name}</span><button class="btn btn-danger" style="padding:4px 10px;font-size:0.75rem;" onclick="removeStudentFromGroup('${group.id}','${s.id}')">Remove</button></li>`).join('') + 
                                '</ul></div>' : 
                                '<p style="color: var(--text-light);">No students in this group yet.</p>'
                            }
                            ${availableStudents.length > 0 ? 
                                `
                                <div class="form-group" style="margin-top: 15px;">
                                    <label>Search students to add</label>
                                    <input type="text" class="group-student-search" data-group-id="${group.id}" placeholder="Type to search..." oninput="onGroupStudentSearchChange('${group.id}', event)">
                                </div>
                                <div class="form-group" style="margin-top: 10px;">
                                    <label>Select students (hold Ctrl/Cmd to select multiple, or Shift to select a range)</label>
                                    <select id="addStudent_${group.id}" multiple size="5" class="form-group select" style="margin-bottom: 10px; width: 100%; padding: 8px;">
                                        ${availableStudents.map(s => `<option value="${s.id}">${s.name}</option>`).join('')}
                                    </select>
                                    <div style="font-size: 0.85rem; color: var(--text-light); margin-bottom: 8px;">üí° Tip: Click while holding Ctrl (Windows) or Cmd (Mac) to select multiple students</div>
                                    <button class="btn btn-primary" onclick="handleAddStudentsToGroup('${group.id}')" style="width: 100%; font-size: 0.9rem; padding: 8px 16px; margin-top: 8px;">Add Selected Students</button>
                                </div>
                                ` :
                                '<p style="color: var(--text-light); margin-top: 10px;">All students are already in this group.</p>'
                            }
                        </div>
                    </div>
                `;
            }).join('');
        }


        // Apply payments/forgiveness as a rolling credit that covers oldest months first.
        function buildMonthlyLedger(student, endYear, endMonth) {
            const created = new Date(student.createdAt);
            const now = new Date();

            // Month list from creation month to current month (inclusive)
            const months = [];
            let y = created.getFullYear();
            let m = created.getMonth();
            const endY = (endYear !== undefined ? endYear : now.getFullYear());
            const endM = (endMonth !== undefined ? endMonth : now.getMonth());
            while (y < endY || (y === endY && m <= endM)) {
                months.push({ year: y, monthIndex: m });
                m++;
                if (m > 11) {
                    m = 0;
                    y++;
                }
            }

            // Credit pool = payments + forgiven (sorted by time so older credits apply first)
            const payments = (Array.isArray(student.payments) ? student.payments : []).map(p => ({
                type: 'payment',
                amount: Number(p.amount || 0),
                date: p.date ? new Date(p.date).getTime() : 0
            }));
            const forgiven = (Array.isArray(student.forgivenRecords) ? student.forgivenRecords : []).map(f => ({
                type: 'forgive',
                amount: Number(f.amount || 0),
                date: f.date ? new Date(f.date).getTime() : 0
            }));
            const credits = [...payments, ...forgiven].filter(c => c.amount > 0).sort((a, b) => a.date - b.date);

            let creditRemaining = credits.reduce((sum, c) => sum + c.amount, 0);

            // Allocate credit across months
            const ledger = new Map(); // key: "YYYY-M"
            months.forEach(({ year, monthIndex }) => {
                const key = `${year}-${monthIndex}`;
                const owed = MONTHLY_FEE;
                const paid = Math.min(owed, creditRemaining);
                creditRemaining -= paid;
                ledger.set(key, { year, monthIndex, owed, paid });
            });

            return { ledger, creditRemaining };
        }

        function getMonthStatusForYear(student, year) {
            // Build ledger through Dec of the requested year so prepayments can show on future months
            const { ledger } = buildMonthlyLedger(student, year, 11);
            const map = new Map(); // monthIndex -> {owed, paid}
            for (let i = 0; i < 12; i++) {
                const key = `${year}-${i}`;
                if (ledger.has(key)) {
                    map.set(i, ledger.get(key));
                }
            }
            return map;
        }

        function getUnpaidMonthsForYear(student, year) {
            const created = new Date(student.createdAt);
            const now = new Date();
            const statuses = getMonthStatusForYear(student, year);

            const months = [];
            for (let i = 0; i < 12; i++) {
                const monthDate = new Date(year, i, 1);
                if (monthDate < new Date(created.getFullYear(), created.getMonth(), 1)) continue;
                // Don't count future months as missing
                if (monthDate > new Date(now.getFullYear(), now.getMonth(), 1)) continue;

                const st = statuses.get(i);
                // If month is in range but has no ledger entry, it means it was before creation/current range; skip.
                if (!st) continue;
                if (st.paid < st.owed) months.push(MONTH_NAMES[i]);
            }
            return months;
        }

        function renderStudentYearPanel(student) {
            const panel = document.getElementById('studentYearPanel');
            if (!panel) return;

            const year = selectedYearForStudent;
            const statuses = getMonthStatusForYear(student, year);
            const created = new Date(student.createdAt);
            const now = new Date();

            const monthsHtml = MONTH_NAMES.map((name, index) => {
                const monthDate = new Date(year, index, 1);
                const afterCreation = monthDate >= new Date(created.getFullYear(), created.getMonth(), 1);
                const isFuture = monthDate > new Date(now.getFullYear(), now.getMonth(), 1);
                const st = statuses.get(index);
                const paid = st ? st.paid : 0;
                const owed = st ? st.owed : MONTHLY_FEE;
                const hasAnyCredit = paid > 0;

                // We show future months as N/A unless there is prepaid credit applied to them
                const inRange = afterCreation && (!isFuture || hasAnyCredit);
                const isPaid = inRange && paid >= owed;
                const isPartial = inRange && paid > 0 && paid < owed;
                return `
                    <div class="month-cell ${!inRange ? '' : (isPaid ? 'month-paid' : 'month-unpaid')}" style="${!inRange ? 'opacity:0.4;' : ''}">
                        <div class="month-name">${name}</div>
                        <div class="month-status">
                            ${!afterCreation ? 'N/A' : (!inRange ? 'N/A' : (isPaid ? 'Paid' : (isPartial ? `Partial ($${paid.toFixed(2)})` : 'Not Paid')))}
                        </div>
                    </div>
                `;
            }).join('');

            panel.style.display = 'block';
            panel.innerHTML = `
                <div class="year-panel-header">
                    <div><strong>${student.name}</strong> ‚Äì Yearly Payments</div>
                    <button class="btn btn-danger" style="padding:6px 10px;font-size:0.8rem;" onclick="document.getElementById('pledgeYearPanel').style.display='none'">Close</button>
                </div>
                <div class="year-selector">
                    <button type="button" onclick="changeStudentYear(-1)">‚Üê Previous Year</button>
                    <div class="year-label">${year}</div>
                    <button type="button" onclick="changeStudentYear(1)">Next Year ‚Üí</button>
                </div>
                <div class="month-grid">
                    ${monthsHtml}
                </div>
            `;
        }

        function showStudentYear(studentId) {
            const student = cachedStudents.find(s => s.id === studentId);
            if (!student) return;
            selectedStudentForYear = studentId;
            selectedYearForStudent = new Date().getFullYear();
            renderStudentYearPanel(student);
        }

        function changeStudentYear(delta) {
            if (!selectedStudentForYear) return;
            selectedYearForStudent += delta;
            const student = cachedStudents.find(s => s.id === selectedStudentForYear);
            if (!student) return;
            renderStudentYearPanel(student);
        }

        // Load Debt View
        let currentDebtIndex = 0;
        let debtStudents = [];

        async function loadDebtView() {
            const students = await getStudents();
            debtStudents = students.filter(s => calculateDebt(s) > 0);
            currentDebtIndex = 0;
            
            const container = document.getElementById('debtViewer');
            
            if (debtStudents.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üí∞</div>
                        <h3>No students in debt!</h3>
                        <p>All students are up to date with their payments.</p>
                    </div>
                `;
                return;
            }
            
            showDebtStudent(0);
        }

        function showDebtStudent(index) {
            if (index < 0 || index >= debtStudents.length) return;
            
            currentDebtIndex = index;
            const student = debtStudents[index];
            const debt = calculateDebt(student);
            const totalPaid = (Array.isArray(student.payments) ? student.payments : []).reduce((sum, p) => sum + (p.amount || 0), 0);
            const totalForgiven = (Array.isArray(student.forgivenRecords) ? student.forgivenRecords : []).reduce((sum, f) => sum + (f.amount || 0), 0);
            const monthsOwed = Math.ceil(debt / MONTHLY_FEE);
            const unpaidMonths = getUnpaidMonthsForYear(student, debtViewYear);

            const hasParentInfo = student.parent && (student.parent.name || student.parent.phone || student.parent.relationship);
            const parentLine = hasParentInfo
                ? `${student.parent.name || 'Parent'}${student.parent.relationship ? ' (' + student.parent.relationship + ')' : ''}`
                : 'No parent info';
            
            const container = document.getElementById('debtViewer');
            container.innerHTML = `
                <div class="debt-student-card">
                    <div style="margin-bottom: 20px;">
                        <span class="badge badge-danger" style="font-size: 1rem; padding: 8px 16px;">Student ${index + 1} of ${debtStudents.length}</span>
                    </div>
                    <div class="debt-student-name">${student.name}</div>
                    <div class="debt-amount">$${debt.toFixed(2)}</div>
                    <div class="debt-info">
                        <div class="debt-info-item">
                            <div class="debt-info-label">Parent Contact</div>
                            <div class="debt-info-value">${parentLine}</div>
                            ${student.parent && student.parent.phone ? `<div style="margin-top: 5px; color: var(--text-light); font-size: 0.9rem;">üìû ${student.parent.phone}</div>` : ''}
                        </div>
                        <div class="debt-info-item">
                            <div class="debt-info-label">Total Paid</div>
                            <div class="debt-info-value">$${totalPaid.toFixed(2)}</div>
                        </div>
                        <div class="debt-info-item">
                            <div class="debt-info-label">Total Forgiven</div>
                            <div class="debt-info-value">$${totalForgiven.toFixed(2)}</div>
                        </div>
                        <div class="debt-info-item">
                            <div class="debt-info-label">Months Owed</div>
                            <div class="debt-info-value">${monthsOwed}</div>
                        </div>
                        <div class="debt-info-item">
                            <div class="debt-info-label">Monthly Fee</div>
                            <div class="debt-info-value">$${MONTHLY_FEE}</div>
                        </div>
                        <div class="debt-info-item">
                            <div class="debt-info-label">Year & Missing Months</div>
                            <div class="debt-info-value">
                                <div class="year-selector" style="margin-bottom:6px;">
                                    <button type="button" onclick="changeDebtViewYear(-1)">‚Üê</button>
                                    <div class="year-label">${debtViewYear}</div>
                                    <button type="button" onclick="changeDebtViewYear(1)">‚Üí</button>
                                </div>
                                ${unpaidMonths.length > 0
                                    ? unpaidMonths.map(m => `<span class="badge-month">${m}</span>`).join('')
                                    : '<span style="font-size:0.85rem;color:var(--text-light);">All months paid for this year.</span>'}
                            </div>
                        </div>
                    </div>
                    <div class="navigation-buttons">
                        <button class="btn btn-primary" onclick="navigateDebt(-1)" ${index === 0 ? 'disabled style="opacity: 0.5;"' : ''}>‚Üê Previous</button>
                        <button class="btn btn-success" onclick="showPaymentModal('${student.id}')">Record Payment</button>
                        <button class="btn btn-primary" onclick="navigateDebt(1)" ${index === debtStudents.length - 1 ? 'disabled style="opacity: 0.5;"' : ''}>Next ‚Üí</button>
                    </div>
                </div>
            `;
        }

        function navigateDebt(direction) {
            const newIndex = currentDebtIndex + direction;
            if (newIndex >= 0 && newIndex < debtStudents.length) {
                showDebtStudent(newIndex);
            }
        }

        function changeDebtViewYear(delta) {
            debtViewYear += delta;
            showDebtStudent(currentDebtIndex);
        }

        // Records tab
        function onRecordSearchChange(e) {
            recordSearchText = e.target.value.toLowerCase();
            loadRecordsSection();
        }

        function loadRecordsSection() {
            const container = document.getElementById('recordsStudentList');
            const details = document.getElementById('recordDetails');
            const students = cachedStudents;

            if (!students || students.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üìö</div><h3>No students yet</h3><p>Add students to see records.</p></div>';
                if (details) {
                    details.style.display = 'none';
                    details.innerHTML = '';
                }
                return;
            }

            const filtered = recordSearchText
                ? students.filter(s => s.name.toLowerCase().includes(recordSearchText))
                : students;

            if (filtered.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üîç</div><h3>No students match your search</h3><p>Try a different name.</p></div>';
                if (details) {
                    details.style.display = 'none';
                    details.innerHTML = '';
                }
                return;
            }

            container.innerHTML = filtered.map(s => {
                const debt = calculateDebt(s);
                const totalPaid = (Array.isArray(s.payments) ? s.payments : []).reduce((sum, p) => sum + (p.amount || 0), 0);
                const totalForgiven = (Array.isArray(s.forgivenRecords) ? s.forgivenRecords : []).reduce((sum, f) => sum + (f.amount || 0), 0);
                return `
                    <div class="card" onclick="showRecordDetails('${s.id}')" style="cursor:pointer;">
                        <div class="card-header">
                            <div class="card-title">${s.name}</div>
                            ${debt > 0 ? '<span class="badge badge-danger">$' + debt + ' debt</span>' : '<span class="badge badge-success">Paid</span>'}
                        </div>
                        <div class="card-body">
                            <div><strong>Total Paid:</strong> $${totalPaid.toFixed(2)}</div>
                            <div><strong>Total Forgiven:</strong> $${totalForgiven.toFixed(2)}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function showRecordDetails(studentId) {
            const details = document.getElementById('recordDetails');
            if (!details) return;

            const student = cachedStudents.find(s => s.id === studentId);
            if (!student) return;

            const payments = Array.isArray(student.payments) ? student.payments : [];
            const forgiven = Array.isArray(student.forgivenRecords) ? student.forgivenRecords : [];
            const charges = Array.isArray(student.chargeRecords) ? student.chargeRecords : [];

            const entries = [
                ...payments.map(p => ({ type: 'payment', ...p })),
                ...forgiven.map(f => ({ type: 'forgiveness', ...f })),
                ...charges.map(c => ({ type: 'charge', ...c }))
            ].sort((a, b) => new Date(b.date) - new Date(a.date));

            const totalPaid = payments.reduce((sum, p) => sum + (p.amount || 0), 0);
            const totalForgiven = forgiven.reduce((sum, f) => sum + (f.amount || 0), 0);
            const totalCharges = charges.reduce((sum, c) => sum + (c.amount || 0), 0);
            const currentDebt = calculateDebt(student);

            const listHtml = entries.length === 0
                ? '<p style="color: var(--text-light);">No records yet for this student.</p>'
                : '<ul style="margin-top: 10px; padding-left: 20px; font-size: 0.9rem;">' +
                    entries.map(entry => {
                        const date = new Date(entry.date);
                        if (entry.type === 'payment') {
                            if (entry.groupName) {
                                // Group payment
                                return `<li><strong>Group Payment</strong>: $${entry.receivedAmount.toFixed(2)} received from ${entry.groupName} (Total: $${entry.totalGroupAmount.toFixed(2)})${entry.method ? ` ‚Äì Method: ${entry.method}` : ''} on ${date.toLocaleString()}</li>`;
                            } else {
                                const methodLabel = entry.method ? ` ‚Äì Method: ${entry.method}` : '';
                                return `<li><strong>Payment</strong>: $${entry.amount.toFixed(2)} for ${entry.month}/${entry.year}${methodLabel} on ${date.toLocaleString()}</li>`;
                            }
                        } else if (entry.type === 'forgiveness') {
                            const reasonLabel = entry.reason ? ` ‚Äì Reason: ${entry.reason}` : '';
                            return `<li><strong>Forgiven</strong>: $${entry.amount.toFixed(2)}${reasonLabel} on ${date.toLocaleString()}</li>`;
                        } else {
                            const reasonLabel = entry.reason ? ` ‚Äì Reason: ${entry.reason}` : '';
                            return `<li><strong>Debt Added</strong>: $${entry.amount.toFixed(2)}${reasonLabel} on ${date.toLocaleString()}</li>`;
                        }
                    }).join('') +
                  '</ul>';

            details.style.display = 'block';
            details.innerHTML = `
                <div class="card-header">
                    <div class="card-title">${student.name}</div>
                    <div style="display:flex;gap:10px;align-items:center;">
                        <span class="badge ${currentDebt > 0 ? 'badge-danger' : 'badge-success'}">
                            ${currentDebt > 0 ? '$' + currentDebt.toFixed(2) + ' debt' : 'No debt'}
                        </span>
                        <button class="btn btn-primary" onclick="downloadStudentPDF('${student.id}')" style="padding:8px 16px;font-size:0.9rem;">üì• Download PDF</button>
                    </div>
                </div>
                <div class="card-body">
                    <div style="margin-bottom: 10px;">
                        <div><strong>Total Paid:</strong> $${totalPaid.toFixed(2)}</div>
                        <div><strong>Total Added Debt:</strong> $${totalCharges.toFixed(2)}</div>
                        <div><strong>Total Forgiven:</strong> $${totalForgiven.toFixed(2)}</div>
                    </div>
                    <div style="margin-top: 10px;">
                        <strong>Records:</strong>
                        ${listHtml}
                    </div>
                </div>
            `;
        }

        // Payment Modal
        async function showPaymentModal(studentId) {
            const students = await getStudents();
            const student = students.find(s => s.id === studentId);
            if (!student) {
                alert('Student not found!');
                return;
            }
            
            const now = new Date();
            const currentMonth = now.toLocaleString('default', { month: 'long' });
            const currentYear = now.getFullYear();
            
            const amount = prompt(`Record payment for ${student.name}\n\nAmount (default: $${MONTHLY_FEE}):`, MONTHLY_FEE);
            if (amount && !isNaN(amount) && parseFloat(amount) > 0) {
                const month = prompt(`Month (default: ${currentMonth}):`, currentMonth);
                const year = prompt(`Year (default: ${currentYear}):`, currentYear);
                const method = prompt('Payment method (optional, e.g. cash, card, bank):', '');
                await recordPayment(studentId, amount, month || currentMonth, year || currentYear, method || '');
            }
        }

        // Add to Group Modal
        async function showAddToGroupModal(studentId) {
            const groups = await getGroups();
            if (groups.length === 0) {
                alert('No groups available. Please create a group first.');
                return;
            }
            
            const groupOptions = groups.map((g, i) => `${i + 1}. ${g.name}`).join('\n');
            const choice = prompt(`Add student to group:\n\n${groupOptions}\n\nEnter group number:`);
            const groupIndex = parseInt(choice) - 1;
            
            if (groupIndex >= 0 && groupIndex < groups.length) {
                await addStudentToGroup(groups[groupIndex].id, studentId);
            }
        }

        // Forgive debt for a student
        async function forgiveDebt(studentId) {
            const students = await getStudents();
            const student = students.find(s => s.id === studentId);
            if (!student) return;

            const currentDebt = calculateDebt(student);
            if (currentDebt <= 0) {
                alert('This student has no debt to forgive.');
                return;
            }

            const amountStr = prompt(`Current debt for ${student.name} is $${currentDebt.toFixed(2)}.\n\nAmount to forgive (default: full debt):`, currentDebt.toFixed(2));
            if (!amountStr || isNaN(amountStr) || parseFloat(amountStr) <= 0) return;
            const amount = parseFloat(amountStr);

            const reason = prompt('Reason for forgiving this debt (optional):', '');

            if (!Array.isArray(student.forgivenRecords)) {
                student.forgivenRecords = [];
            }

            student.forgivenRecords.push({
                id: Date.now().toString(),
                amount,
                reason: reason || '',
                date: new Date().toISOString()
            });

            await saveStudents(students);

            loadDashboard();
            loadStudents();
            loadDebtView();
        }

        // Add extra debt/charge (one-time) for a student (shows in Records)
        async function addDebt(studentId) {
            const students = await getStudents();
            const student = students.find(s => s.id === studentId);
            if (!student) return;

            const amountStr = prompt(`Add debt/charge for ${student.name}\n\nAmount:`, '0');
            if (!amountStr || isNaN(amountStr) || parseFloat(amountStr) <= 0) return;
            const amount = parseFloat(amountStr);

            const reason = prompt('Reason (optional):', '');

            if (!Array.isArray(student.chargeRecords)) {
                student.chargeRecords = [];
            }

            student.chargeRecords.push({
                id: Date.now().toString(),
                amount,
                reason: reason || '',
                date: new Date().toISOString()
            });

            await saveStudents(students);

            loadDashboard();
            loadStudents();
            loadDebtView();
        }

        // Remove student from a specific group
        async function removeStudentFromGroup(groupId, studentId) {
            const groups = await getGroups();
            const students = await getStudents();

            const group = groups.find(g => g.id === groupId);
            if (group) {
                group.studentIds = group.studentIds.filter(id => id !== studentId);
            }

            const student = students.find(s => s.id === studentId);
            if (student && Array.isArray(student.groups)) {
                student.groups = student.groups.filter(id => id !== groupId);
            }

            await saveGroups(groups);
            await saveStudents(students);

            loadGroups();
            loadStudents();
        }

        // Delete student completely (from students and all groups)
        async function deleteStudent(studentId) {
            if (!confirm('Are you sure you want to delete this student completely?')) return;

            const students = await getStudents();
            const groups = await getGroups();

            const newStudents = students.filter(s => s.id !== studentId);
            groups.forEach(g => {
                g.studentIds = g.studentIds.filter(id => id !== studentId);
            });

            await saveGroups(groups);
            await saveStudents(newStudents);

            // If this student was selected in the year panel, hide it
            if (selectedStudentForYear === studentId) {
                const panel = document.getElementById('studentYearPanel');
                if (panel) {
                    panel.style.display = 'none';
                    panel.innerHTML = '';
                }
                selectedStudentForYear = null;
            }

            loadDashboard();
            loadStudents();
            loadGroups();
            loadDebtView();
        }

        // Settings actions
        async function clearAllData() {
            if (!confirm('This will delete ALL students, groups, payments, and forgiveness records. Are you sure?')) return;

            await saveStudents([]);
            await saveGroups([]);

            cachedStudents = [];
            cachedGroups = [];

            const recordsList = document.getElementById('recordsStudentList');
            const recordDetails = document.getElementById('recordDetails');
            if (recordsList) recordsList.innerHTML = '';
            if (recordDetails) {
                recordDetails.style.display = 'none';
                recordDetails.innerHTML = '';
            }

            loadDashboard();
            loadStudents();
            loadGroups();
            loadDebtView();
        }

        async function clearAllDebtAndRecords() {
            if (!confirm('This will forgive all existing debt and clear all past records by resetting history from today. Continue?')) return;

            const students = await getStudents();
            const now = new Date().toISOString();

            students.forEach(s => {
                s.createdAt = now;
                s.payments = [];
                s.forgivenRecords = [];
                s.chargeRecords = [];
            });

            await saveStudents(students);

            loadDashboard();
            loadStudents();
            loadGroups();
            loadDebtView();
        }

        async function clearAllRecordsOnly() {
            if (!confirm('This will clear all payments and forgiveness records but keep students and groups. Continue?')) return;

            const students = await getStudents();

            students.forEach(s => {
                s.payments = [];
                s.forgivenRecords = [];
                s.chargeRecords = [];
            });

            await saveStudents(students);
        }

        // Record Group Payment
        async function recordGroupPayment(groupId) {
            const groups = await getGroups();
            const group = groups.find(g => g.id === groupId);
            if (!group) return;

            const students = await getStudents();
            const groupStudents = students.filter(s => group.studentIds.includes(s.id));
            
            if (groupStudents.length === 0) {
                alert('No students in this group.');
                return;
            }

            const totalAmountStr = prompt(`Record group payment for ${group.name}\n\nTotal Amount:`, '0');
            if (!totalAmountStr || isNaN(totalAmountStr) || parseFloat(totalAmountStr) <= 0) return;
            const totalAmount = parseFloat(totalAmountStr);

            const method = prompt('Payment method (optional):', '');

            // Split payment equally among group members
            const amountPerStudent = totalAmount / groupStudents.length;

            const paymentDate = new Date().toISOString();
            const paymentId = Date.now().toString();

            groupStudents.forEach(student => {
                if (!Array.isArray(student.payments)) {
                    student.payments = [];
                }
                student.payments.push({
                    id: paymentId,
                    amount: amountPerStudent,
                    method: method ? `Group Payment (${method})` : 'Group Payment',
                    date: paymentDate,
                    groupId: groupId,
                    groupName: group.name,
                    totalGroupAmount: totalAmount,
                    receivedAmount: amountPerStudent
                });
            });

            await saveStudents(students);
            loadDashboard();
            loadGroups();
            loadDebtView();
            showAlert('groupAlert', `Group payment of $${totalAmount.toFixed(2)} recorded and split among ${groupStudents.length} students!`, 'success');
        }

        // End All Active Pledges
        async function endAllActivePledges() {
            if (!confirm('Are you sure you want to end all active pledges? They will be moved to records.')) return;
            
            const pledges = await getPledges();
            const now = new Date().toISOString();
            
            pledges.forEach(pledge => {
                if (!pledge.completed) {
                    pledge.completed = true;
                    pledge.completedDate = now;
                }
            });
            
            await savePledges(pledges);
            loadPledges();
            loadPledgeRecords();
            loadDashboard();
            showAlert('pledgeAlert', 'All active pledges have been ended and moved to records!', 'success');
        }

        // Delete All Pledges
        async function deleteAllPledges() {
            if (!confirm('Are you sure you want to delete ALL pledges and pledge records? This cannot be undone!')) return;
            if (!confirm('This will permanently delete everything. Are you absolutely sure?')) return;
            
            await savePledges([]);
            loadPledges();
            loadPledgeRecords();
            loadDashboard();
            showAlert('pledgeAlert', 'All pledges and records have been deleted!', 'success');
        }

        // Alert helper
        function showAlert(containerId, message, type) {
            const container = document.getElementById(containerId);
            container.innerHTML = `<div class="alert alert-${type}">${message}</div>`;
            setTimeout(() => {
                container.innerHTML = '';
            }, 3000);
        }

        // Keyboard navigation for debt viewer
        document.addEventListener('keydown', function(e) {
            const debtSection = document.getElementById('debt');
            if (debtSection.classList.contains('active') && debtStudents.length > 0) {
                if (e.key === 'ArrowLeft') {
                    navigateDebt(-1);
                } else if (e.key === 'ArrowRight') {
                    navigateDebt(1);
                }
            }
        });

        // Delete Group
        async function deleteGroup(groupId) {
            if (!confirm('Are you sure you want to delete this group? Students will remain but will be removed from this group.')) return;

            const groups = await getGroups();
            const students = await getStudents();

            const group = groups.find(g => g.id === groupId);
            if (group) {
                // Remove group from all students
                students.forEach(s => {
                    if (Array.isArray(s.groups)) {
                        s.groups = s.groups.filter(id => id !== groupId);
                    }
                });
            }

            const newGroups = groups.filter(g => g.id !== groupId);
            await saveGroups(newGroups);
            await saveStudents(students);

            loadGroups();
            loadStudents();
        }

        // Download Student PDF
        function downloadStudentPDF(studentId) {
            const student = cachedStudents.find(s => s.id === studentId);
            if (!student) return;

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            const payments = Array.isArray(student.payments) ? student.payments : [];
            const forgiven = Array.isArray(student.forgivenRecords) ? student.forgivenRecords : [];
            const charges = Array.isArray(student.chargeRecords) ? student.chargeRecords : [];

            const totalPaid = payments.reduce((sum, p) => sum + (p.amount || 0), 0);
            const totalForgiven = forgiven.reduce((sum, f) => sum + (f.amount || 0), 0);
            const totalCharges = charges.reduce((sum, c) => sum + (c.amount || 0), 0);
            const currentDebt = calculateDebt(student);

            let y = 20;
            doc.setFontSize(18);
            doc.text(`Student Records: ${student.name}`, 14, y);
            y += 15;

            doc.setFontSize(12);
            doc.text(`Total Paid: $${totalPaid.toFixed(2)}`, 14, y);
            y += 7;
            doc.text(`Total Added Debt: $${totalCharges.toFixed(2)}`, 14, y);
            y += 7;
            doc.text(`Total Forgiven: $${totalForgiven.toFixed(2)}`, 14, y);
            y += 7;
            doc.text(`Current Debt: $${currentDebt.toFixed(2)}`, 14, y);
            y += 10;

            const entries = [
                ...payments.map(p => ({ type: 'Payment', ...p })),
                ...forgiven.map(f => ({ type: 'Forgiven', ...f })),
                ...charges.map(c => ({ type: 'Debt Added', ...c }))
            ].sort((a, b) => new Date(b.date) - new Date(a.date));

            if (entries.length > 0) {
                doc.text('Transaction History:', 14, y);
                y += 7;
                doc.setFontSize(10);
                entries.forEach(entry => {
                    if (y > 280) {
                        doc.addPage();
                        y = 20;
                    }
                    const date = new Date(entry.date);
                    let text = `${entry.type}: $${entry.amount.toFixed(2)} - ${date.toLocaleString()}`;
                    if (entry.type === 'Payment' && entry.method) text += ` (Method: ${entry.method})`;
                    if (entry.reason) text += ` (Reason: ${entry.reason})`;
                    doc.text(text, 14, y);
                    y += 6;
                });
            }

            // Add date generated
            y += 10;
            doc.setFontSize(8);
            doc.setTextColor(128, 128, 128);
            doc.text(`Report generated: ${new Date().toLocaleString()}`, 14, y);

            doc.save(`${student.name}_Records.pdf`);
        }

        // Gemini API Keys
        const GEMINI_KEYS = [
            'AIzaSyAaDVm2iSoLZjQrQTR-JP7jjREVsD3IiTo',
            'AIzaSyC1ENitxQXsMJF-KxfnarD6d4Mx2snLK7s',
            'AIzaSyBhmCdjh2YKsun8Q6pzE8cDenlhQWZAIeY',
            'AIzaSyBFPVNOlU3zM-kpzxCf1RT3xSrO8anqsPE',
            'AIzaSyAYBbt3ebd2OXRcbPfHersULp4A70lctQ4'
        ];
        let currentGeminiKeyIndex = 0;

        // Extract text from file
        async function extractTextFromFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    resolve(text);
                };
                reader.onerror = reject;
                if (file.type === 'application/pdf') {
                    // For PDF, we'll send to Gemini API directly
                    reader.readAsDataURL(file);
                } else {
                    reader.readAsText(file);
                }
            });
        }

        // Call Gemini API
        async function callGeminiAPI(text, isBase64 = false) {
            const startTime = Date.now();
            const maxWait = 60000; // 1 minute

            while (Date.now() - startTime < maxWait) {
                const key = GEMINI_KEYS[currentGeminiKeyIndex];
                try {
                    let body;
                    if (isBase64) {
                        body = JSON.stringify({
                            contents: [{
                                parts: [
                                    {
                                        text: `Extract ALL student names and parent information from this document. SCAN THOROUGHLY for:
- Student names (any capitalized names, each row/line is a separate student)
- Parent names (look for "Parent:", "Mom:", "Dad:", "Mother:", "Father:", "Guardian:" or names near student names)
- Phone numbers (any format: 123-456-7890, (123) 456-7890, 123.456.7890, 1234567890, etc.)
- Relationships (Mom, Dad, Mother, Father, Guardian, etc.)

IMPORTANT: Return ONLY a valid JSON array, no other text. Each object must have: name (required), parentName (optional), parentPhone (optional), relationship (optional).

Example: [{"name":"John Doe","parentName":"Jane Doe","parentPhone":"123-456-7890","relationship":"Mom"}]

SCAN EVERY ROW AND COLUMN THOROUGHLY.`
                                    },
                                    {
                                        inline_data: {
                                            mime_type: "application/pdf",
                                            data: text.split(',')[1]
                                        }
                                    }
                                ]
                            }]
                        });
                    } else {
                        body = JSON.stringify({
                            contents: [{
                                parts: [{
                                    text: `Extract ALL student names and parent information from this text. SCAN THOROUGHLY for:
- Student names (any capitalized names)
- Parent names (look for "Parent:", "Mom:", "Dad:", "Mother:", "Father:", "Guardian:" or names near student names)
- Phone numbers (any format: 123-456-7890, (123) 456-7890, 123.456.7890, 1234567890, etc.)
- Relationships (Mom, Dad, Mother, Father, Guardian, etc.)

IMPORTANT: You must return ONLY a valid JSON array, no other text, no explanations, no markdown formatting. The response must start with [ and end with ].

Each object in the array must have these exact fields:
- name: (string, required) - student name
- parentName: (string, optional) - parent name if found (scan for any name near the student name)
- parentPhone: (string, optional) - parent phone if found (any phone number format)
- relationship: (string, optional) - "Mom", "Dad", "Guardian", or "Other" if found

SCAN EVERY LINE THOROUGHLY. Look for patterns like:
- Student Name - Parent Name - Phone
- Student Name (Mom: Parent Name, Phone: 123-456-7890)
- Student Name | Parent Name | Phone
- Any format where student and parent info appear together

Example format:
[{"name":"John Doe","parentName":"Jane Doe","parentPhone":"123-456-7890","relationship":"Mom"}]

Text to extract from:
${text}`
                                }]
                            }]
                        });
                    }

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${key}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: body
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const data = await response.json();
                    if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                        throw new Error('Invalid API response structure');
                    }
                    const content = data.candidates[0].content.parts[0].text;
                    
                    // Try multiple strategies to extract JSON
                    // Strategy 1: Look for JSON array directly
                    let jsonMatch = content.match(/\[[\s\S]*?\]/);
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (Array.isArray(parsed) && parsed.length > 0) return parsed;
                        } catch (e) {
                            // Try to fix common JSON issues
                            let fixed = jsonMatch[0]
                                .replace(/,\s*}/g, '}')  // Remove trailing commas before }
                                .replace(/,\s*]/g, ']')  // Remove trailing commas before ]
                                .replace(/'/g, '"')       // Replace single quotes with double
                                .replace(/(\w+):/g, '"$1":'); // Add quotes to keys
                            try {
                                const parsed = JSON.parse(fixed);
                                if (Array.isArray(parsed)) return parsed;
                            } catch (e2) {}
                        }
                    }
                    
                    // Strategy 2: Look for JSON in code blocks
                    jsonMatch = content.match(/```(?:json)?\s*(\[[\s\S]*?\])\s*```/);
                    if (jsonMatch && jsonMatch[1]) {
                        try {
                            const parsed = JSON.parse(jsonMatch[1]);
                            if (Array.isArray(parsed)) return parsed;
                        } catch (e) {}
                    }
                    
                    // Strategy 3: Try to find and fix malformed JSON
                    jsonMatch = content.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        let jsonStr = jsonMatch[0];
                        // Fix common issues
                        jsonStr = jsonStr
                            .replace(/,\s*}/g, '}')
                            .replace(/,\s*]/g, ']')
                            .replace(/'/g, '"')
                            .replace(/([{,]\s*)(\w+)(\s*:)/g, '$1"$2"$3'); // Quote keys
                        try {
                            const parsed = JSON.parse(jsonStr);
                            if (Array.isArray(parsed)) return parsed;
                        } catch (e) {}
                    }
                    
                    // Strategy 4: Extract names from text (handles lists, tables, plain text) WITH PARENT INFO
                    const students = [];
                    const foundNames = new Set();
                    
                    // Phone number pattern (various formats)
                    const phonePattern = /(\+?\d{1,3}[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}|\d{10,}/g;
                    
                    // First, try to extract from tables (each row = one student with columns)
                    const tableRows = content.match(/\|[\s\S]*?\|/g);
                    if (tableRows && tableRows.length > 1) {
                        // Skip header row
                        for (let i = 1; i < tableRows.length; i++) {
                            const row = tableRows[i];
                            const cells = row.split('|').map(c => c.trim()).filter(c => c.length > 0);
                            
                            if (cells.length > 0) {
                                const student = {
                                    name: '',
                                    parentName: '',
                                    parentPhone: '',
                                    relationship: ''
                                };
                                
                                // First cell is usually student name
                                if (cells[0]) {
                                    const nameMatch = cells[0].match(/^([A-Z][a-z]+(?:\s{1,2}[A-Z][a-z]+)?)/);
                                    if (nameMatch) {
                                        student.name = nameMatch[1].trim();
                                    }
                                }
                                
                                // Look for parent info in other cells
                                for (let j = 1; j < cells.length; j++) {
                                    const cell = cells[j];
                                    
                                    // Check for phone
                                    const phoneMatch = cell.match(phonePattern);
                                    if (phoneMatch && !student.parentPhone) {
                                        student.parentPhone = phoneMatch[0].replace(/\s+/g, ' ').trim();
                                    }
                                    
                                    // Check for parent name patterns
                                    const parentMatch = cell.match(/(?:parent|mom|dad|mother|father|guardian)[\s:]*([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/i) ||
                                                       cell.match(/^([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)$/);
                                    if (parentMatch && parentMatch[1] && !student.parentName) {
                                        student.parentName = parentMatch[1].trim();
                                    }
                                    
                                    // Check for relationship
                                    const relMatch = cell.match(/\b(mom|dad|mother|father|guardian|parent)\b/i);
                                    if (relMatch && !student.relationship) {
                                        const rel = relMatch[1].toLowerCase();
                                        student.relationship = rel.includes('mom') || rel.includes('mother') ? 'Mom' :
                                                             rel.includes('dad') || rel.includes('father') ? 'Dad' :
                                                             rel.includes('guardian') ? 'Guardian' : 'Other';
                                    }
                                }
                                
                                if (student.name && student.name.length > 2) {
                                    const lowerName = student.name.toLowerCase();
                                    const skipWords = ['column', 'name', 'student', 'table', 'list', 'header'];
                                    if (!skipWords.some(word => lowerName.includes(word)) && !foundNames.has(lowerName)) {
                                        foundNames.add(lowerName);
                                        students.push(student);
                                    }
                                }
                            }
                        }
                    }
                    
                    // If we found table rows, return them
                    if (students.length > 0) return students;
                    
                    // For plain text: split by lines and extract student + parent info
                    const lines = content.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        const nextLine = i < lines.length - 1 ? lines[i + 1] : '';
                        
                        // Skip header lines, table headers, etc.
                        if (line.match(/^(name|student|column|table|list|here|contains|extracted|data|text|content|image|header|the|image|contains|text|content)/i)) continue;
                        if (line.match(/^[-*‚Ä¢\|\d\.\s:]*$/)) continue; // Only separators
                        if (line.match(/^[|:\-_\s]+$/)) continue; // Table separators
                        
                        // Remove list markers and leading separators
                        let cleanLine = line.replace(/^[-*‚Ä¢\|\d\.\s:]+/, '').trim();
                        
                        // Extract student name
                        const nameMatch = cleanLine.match(/^([A-Z][a-z]+(?:\s{1,2}[A-Z][a-z]+)?)/);
                        if (!nameMatch) continue;
                        
                        const name = nameMatch[1].trim();
                        const lowerName = name.toLowerCase();
                        const skipWords = ['column', 'name', 'student', 'table', 'list', 'contains', 'here', 'data', 'extracted', 'text', 'content', 'image', 'header', 'the', 'and', 'or'];
                        
                        if (name.length < 2 || name.length > 50 || 
                            skipWords.some(word => lowerName === word || lowerName.includes(word)) ||
                            foundNames.has(lowerName)) continue;
                        
                        foundNames.add(lowerName);
                        
                        const student = {
                            name: name,
                            parentName: '',
                            parentPhone: '',
                            relationship: ''
                        };
                        
                        // Look for parent info in the same line or next line
                        const searchText = cleanLine + ' ' + nextLine;
                        
                        // Extract phone number
                        const phoneMatch = searchText.match(phonePattern);
                        if (phoneMatch) {
                            student.parentPhone = phoneMatch[0].replace(/\s+/g, ' ').trim();
                        }
                        
                        // Extract parent name (look for patterns like "Parent: Name", "Mom: Name", or name after student name)
                        const parentPatterns = [
                            /(?:parent|mom|dad|mother|father|guardian)[\s:]+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/i,
                            /(?:parent|mom|dad|mother|father|guardian)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/i,
                            // Name after student name (if separated by dash, comma, or multiple spaces)
                            new RegExp(name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\s*[-,\\|]\\s*([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)?)'),
                            // Name in next line if current line is just the student name
                            cleanLine === name && nextLine ? new RegExp('^([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)?)') : null
                        ].filter(p => p !== null);
                        
                        for (const pattern of parentPatterns) {
                            const match = searchText.match(pattern);
                            if (match && match[1] && match[1].toLowerCase() !== lowerName) {
                                student.parentName = match[1].trim();
                                break;
                            }
                        }
                        
                        // Extract relationship
                        const relMatch = searchText.match(/\b(mom|dad|mother|father|guardian|parent)\b/i);
                        if (relMatch) {
                            const rel = relMatch[1].toLowerCase();
                            student.relationship = rel.includes('mom') || rel.includes('mother') ? 'Mom' :
                                                   rel.includes('dad') || rel.includes('father') ? 'Dad' :
                                                   rel.includes('guardian') ? 'Guardian' : 'Other';
                        }
                        
                        students.push(student);
                    }
                    
                    // If still no students, try simpler pattern: one name per line
                    if (students.length === 0) {
                        for (const line of lines) {
                            if (line.match(/^(name|student|column|table|list|here|contains|extracted|data|text|content|image|header|the)/i)) continue;
                            if (line.match(/^[-*‚Ä¢\|\d\.\s:]*$/)) continue;
                            
                            let cleanLine = line.replace(/^[-*‚Ä¢\|\d\.\s:]+/, '').trim();
                            
                            // Look for a single capitalized name (1-2 words with 1-2 spaces)
                            const nameMatch = cleanLine.match(/^([A-Z][a-z]+(?:\s{1,2}[A-Z][a-z]+)?)\s*$/);
                            if (nameMatch) {
                                const name = nameMatch[1].trim();
                                const lowerName = name.toLowerCase();
                                const skipWords = ['column', 'name', 'student', 'table', 'list', 'contains', 'here', 'data', 'extracted', 'text', 'content', 'image', 'header', 'the'];
                                if (name.length > 2 && name.length < 50 && 
                                    !skipWords.some(word => lowerName === word || lowerName.includes(word)) &&
                                    !foundNames.has(lowerName)) {
                                    foundNames.add(lowerName);
                                    students.push({
                                        name: name,
                                        parentName: '',
                                        parentPhone: '',
                                        relationship: ''
                                    });
                                }
                            }
                        }
                    }
                    
                    if (students.length > 0) return students;
                    
                    // Last resort: try to parse the whole content
                    try {
                        const parsed = JSON.parse(content);
                        if (Array.isArray(parsed)) return parsed;
                        if (parsed.students && Array.isArray(parsed.students)) return parsed.students;
                        return [parsed];
                    } catch (e) {
                        throw new Error('Could not extract valid JSON from API response. Content: ' + content.substring(0, 200));
                    }
                } catch (error) {
                    console.error(`Gemini API key ${currentGeminiKeyIndex + 1} failed:`, error);
                    currentGeminiKeyIndex = (currentGeminiKeyIndex + 1) % GEMINI_KEYS.length;
                    if (currentGeminiKeyIndex === 0) {
                        // Waited 10 seconds before retrying
                        await new Promise(resolve => setTimeout(resolve, 10000));
                    }
                }
            }
            throw new Error('All API keys failed or timeout reached');
        }

        // Handle File Upload
        async function handleFileUpload() {
            const fileInput = document.getElementById('fileUpload');
            const statusDiv = document.getElementById('fileUploadStatus');
            const previewDiv = document.getElementById('extractedStudentsPreview');

            if (!fileInput.files || fileInput.files.length === 0) {
                statusDiv.innerHTML = '<span style="color: var(--danger);">Please select a file first.</span>';
                return;
            }

            const file = fileInput.files[0];
            statusDiv.innerHTML = '<span style="color: var(--primary);">‚è≥ Processing file...</span>';

            try {
                let extractedData;
                if (file.type === 'application/pdf') {
                    const reader = new FileReader();
                    const base64 = await new Promise((resolve, reject) => {
                        reader.onload = (e) => resolve(e.target.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });
                    extractedData = await callGeminiAPI(base64, true);
                } else {
                    const text = await extractTextFromFile(file);
                    extractedData = await callGeminiAPI(text, false);
                }

                if (!Array.isArray(extractedData) || extractedData.length === 0) {
                    statusDiv.innerHTML = '<span style="color: var(--danger);">No students found in the file.</span>';
                    return;
                }

                statusDiv.innerHTML = `<span style="color: var(--secondary);">‚úÖ Found ${extractedData.length} student(s). Review and edit below:</span>`;
                
                // Show preview for editing
                previewDiv.style.display = 'block';
                previewDiv.innerHTML = `
                    <div class="card" style="background: #f0f9ff;">
                        <h3 style="margin-bottom: 15px;">Review Extracted Students</h3>
                        <div id="extractedStudentsList"></div>
                        <div style="margin-top: 20px; display: flex; gap: 10px;">
                            <button class="btn btn-success" onclick="acceptExtractedStudents()">‚úÖ Accept All</button>
                            <button class="btn btn-danger" onclick="document.getElementById('extractedStudentsPreview').style.display='none'">‚ùå Cancel</button>
                        </div>
                    </div>
                `;

                window.extractedStudentsData = extractedData;
                const listDiv = document.getElementById('extractedStudentsList');
                listDiv.innerHTML = extractedData.map((s, idx) => {
                    // Ensure we have proper values - handle both name and text_content fields
                    const studentName = String(s.name || s.text_content || '').trim();
                    const parentName = String(s.parentName || s.parent?.name || '').trim();
                    const parentPhone = String(s.parentPhone || s.parent?.phone || s.phone || '').trim();
                    const relationship = String(s.relationship || s.parent?.relationship || '').trim();
                    
                    // Skip entries without valid names
                    if (!studentName || studentName.length < 2) {
                        return '';
                    }
                    
                    return `
                        <div class="card" style="margin-bottom: 10px;" id="ext_card_${idx}">
                            <div id="ext_view_${idx}">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <div>
                                        <strong>${studentName}</strong>
                                        ${parentName ? `<div style="color: var(--text-light); font-size: 0.9rem;">Parent: ${parentName}</div>` : ''}
                                        ${parentPhone ? `<div style="color: var(--text-light); font-size: 0.9rem;">Phone: ${parentPhone}</div>` : ''}
                                        ${relationship ? `<div style="color: var(--text-light); font-size: 0.9rem;">Relationship: ${relationship}</div>` : ''}
                                    </div>
                                    <button class="btn btn-primary" onclick="toggleEditStudent(${idx})" style="padding: 6px 12px; font-size: 0.85rem;">‚úèÔ∏è Edit</button>
                                </div>
                            </div>
                            <div id="ext_edit_${idx}" style="display: none;">
                                <div class="form-group">
                                    <label>Student Name *</label>
                                    <input type="text" id="ext_name_${idx}" value="${studentName}" style="width: 100%; padding: 8px;" required>
                                </div>
                                <div class="form-group">
                                    <label>Parent Name</label>
                                    <input type="text" id="ext_parent_${idx}" value="${parentName}" style="width: 100%; padding: 8px;">
                                </div>
                                <div class="form-group">
                                    <label>Parent Phone</label>
                                    <input type="tel" id="ext_phone_${idx}" value="${parentPhone}" style="width: 100%; padding: 8px;">
                                </div>
                                <div class="form-group">
                                    <label>Relationship</label>
                                    <select id="ext_rel_${idx}" style="width: 100%; padding: 8px;">
                                        <option value="">Select...</option>
                                        <option value="Mom" ${relationship === 'Mom' ? 'selected' : ''}>Mom</option>
                                        <option value="Dad" ${relationship === 'Dad' ? 'selected' : ''}>Dad</option>
                                        <option value="Guardian" ${relationship === 'Guardian' ? 'selected' : ''}>Guardian</option>
                                        <option value="Other" ${relationship === 'Other' ? 'selected' : ''}>Other</option>
                                    </select>
                                </div>
                                <button class="btn btn-success" onclick="toggleEditStudent(${idx})" style="width: 100%; margin-top: 10px;">‚úÖ Done Editing</button>
                            </div>
                        </div>
                    `;
                }).filter(html => html && html.trim().length > 0).join('');
            } catch (error) {
                statusDiv.innerHTML = `<span style="color: var(--danger);">‚ùå Error: ${error.message}</span>`;
            }
        }

        // Toggle upload panel
        function toggleUploadPanel() {
            const panel = document.getElementById('uploadPanel');
            if (panel) {
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Toggle edit mode for extracted student
        function toggleEditStudent(idx) {
            const viewDiv = document.getElementById(`ext_view_${idx}`);
            const editDiv = document.getElementById(`ext_edit_${idx}`);
            if (viewDiv && editDiv) {
                const isEditing = editDiv.style.display !== 'none';
                viewDiv.style.display = isEditing ? 'block' : 'none';
                editDiv.style.display = isEditing ? 'none' : 'block';
                
                if (!isEditing) {
                    // Update view with current values
                    const name = document.getElementById(`ext_name_${idx}`).value;
                    const parent = document.getElementById(`ext_parent_${idx}`).value;
                    const phone = document.getElementById(`ext_phone_${idx}`).value;
                    const rel = document.getElementById(`ext_rel_${idx}`).value;
                    
                    viewDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div>
                                <strong>${name || 'Unnamed Student'}</strong>
                                ${parent ? `<div style="color: var(--text-light); font-size: 0.9rem;">Parent: ${parent}</div>` : ''}
                                ${phone ? `<div style="color: var(--text-light); font-size: 0.9rem;">Phone: ${phone}</div>` : ''}
                                ${rel ? `<div style="color: var(--text-light); font-size: 0.9rem;">Relationship: ${rel}</div>` : ''}
                            </div>
                            <button class="btn btn-primary" onclick="toggleEditStudent(${idx})" style="padding: 6px 12px; font-size: 0.85rem;">‚úèÔ∏è Edit</button>
                        </div>
                    `;
                }
            }
        }

        // Accept Extracted Students
        async function acceptExtractedStudents() {
            if (!window.extractedStudentsData) return;

            const students = await getStudents();
            const newStudents = window.extractedStudentsData.map((s, idx) => {
                // Always read from input fields (they're always present, just hidden when in view mode)
                const nameInput = document.getElementById(`ext_name_${idx}`);
                const parentInput = document.getElementById(`ext_parent_${idx}`);
                const phoneInput = document.getElementById(`ext_phone_${idx}`);
                const relInput = document.getElementById(`ext_rel_${idx}`);
                
                const name = nameInput ? nameInput.value.trim() : (s.name || '').trim();
                const parentName = parentInput ? parentInput.value.trim() : (s.parentName || s.parent?.name || '').trim();
                const parentPhone = phoneInput ? phoneInput.value.trim() : (s.parentPhone || s.parent?.phone || s.phone || '').trim();
                const relationship = relInput ? relInput.value.trim() : (s.relationship || s.parent?.relationship || '').trim();
                
                if (!name) return null;
                return {
                    id: Date.now().toString() + idx,
                    name: name,
                    parent: {
                        name: parentName,
                        phone: parentPhone,
                        relationship: relationship
                    },
                    groups: [],
                    payments: [],
                    chargeRecords: [],
                    forgivenRecords: [],
                    createdAt: new Date().toISOString()
                };
            }).filter(Boolean);

            students.push(...newStudents);
            await saveStudents(students);

            document.getElementById('fileUpload').value = '';
            document.getElementById('fileUploadStatus').innerHTML = '';
            document.getElementById('extractedStudentsPreview').style.display = 'none';
            window.extractedStudentsData = null;

            showAlert('studentAlert', `Successfully added ${newStudents.length} student(s)!`, 'success');
            loadStudents();
            loadDashboard();
        }

        // Pledges functions
        async function getPledges() {
            return await redisGet('pledges') || [];
        }

        async function savePledges(pledges) {
            return await redisSet('pledges', pledges);
        }

        function updatePledgeDateOptions() {
            const schedule = document.getElementById('pledgeSchedule').value;
            const dateGroup = document.getElementById('pledgeDateGroup');
            const recurringGroup = document.getElementById('pledgeRecurringGroup');

            if (dateGroup) dateGroup.style.display = schedule === 'byDate' ? 'block' : 'none';
            if (recurringGroup) recurringGroup.style.display = schedule === 'recurring' ? 'block' : 'none';
        }

        async function addPledge(e) {
            e.preventDefault();
            const name = document.getElementById('pledgeName').value;
            const phone = document.getElementById('pledgePhone').value;
            const amount = parseFloat(document.getElementById('pledgeAmount').value);
            const schedule = document.getElementById('pledgeSchedule').value;

            if (!name || !amount || !schedule) {
                showAlert('pledgeAlert', 'Please fill all required fields.', 'error');
                return;
            }

            let targetDate = null;
            let recurringDays = null;

            if (schedule === 'byDate') {
                const dateInput = document.getElementById('pledgeDate').value;
                if (!dateInput) {
                    showAlert('pledgeAlert', 'Please select a target date.', 'error');
                    return;
                }
                targetDate = dateInput;
            } else if (schedule === 'recurring') {
                const recurring = document.getElementById('pledgeRecurring').value;
                if (!recurring) {
                    showAlert('pledgeAlert', 'Please select a recurring frequency.', 'error');
                    return;
                }
                recurringDays = parseInt(recurring);
            } else {
                // Calculate target date based on days
                const days = parseInt(schedule);
                const date = new Date();
                date.setDate(date.getDate() + days);
                targetDate = date.toISOString().split('T')[0];
            }

            const pledges = await getPledges();
            const newPledge = {
                id: Date.now().toString(),
                name: name,
                phone: phone || '',
                pledgedAmount: amount,
                schedule: schedule,
                targetDate: targetDate,
                recurringDays: recurringDays,
                payments: [],
                chargeRecords: [],
                forgivenRecords: [],
                createdAt: new Date().toISOString(),
                completed: false
            };

            pledges.push(newPledge);
            await savePledges(pledges);

            document.getElementById('pledgeForm').reset();
            updatePledgeDateOptions();
            showAlert('pledgeAlert', 'Pledge added successfully!', 'success');
            loadPledges();
        }

        // Calculate RPP Debt (for "over X days" pledges - based on daily payment plan)
        function calculateRPPDebt(pledge) {
            if (pledge.schedule === 'byDate' || isNaN(parseInt(pledge.schedule))) {
                // Not an "over X days" pledge, use regular calculation
                return calculatePledgeDebt(pledge);
            }
            
            const days = parseInt(pledge.schedule);
            const dailyAmount = (pledge.pledgedAmount || 0) / days;
            const now = new Date();
            const created = new Date(pledge.createdAt);
            const daysSinceCreation = Math.floor((now - created) / (1000 * 60 * 60 * 24));
            const daysElapsed = Math.min(daysSinceCreation, days);
            
            const totalPaid = (Array.isArray(pledge.payments) ? pledge.payments : []).reduce((sum, p) => sum + (p.amount || 0), 0);
            const totalForgiven = (Array.isArray(pledge.forgivenRecords) ? pledge.forgivenRecords : []).reduce((sum, f) => sum + (f.amount || 0), 0);
            
            // Expected payment based on RPP (daily amount * days elapsed)
            const expectedPayment = dailyAmount * daysElapsed;
            
            // Debt is expected payment minus what was paid/forgiven
            return Math.max(0, expectedPayment - totalPaid - totalForgiven);
        }

        // Calculate Pledge Debt (includes recurring and time-based debt)
        function calculatePledgeDebt(pledge) {
            const now = new Date();
            const created = new Date(pledge.createdAt);
            const totalPaid = (Array.isArray(pledge.payments) ? pledge.payments : []).reduce((sum, p) => sum + (p.amount || 0), 0);
            const totalCharges = (Array.isArray(pledge.chargeRecords) ? pledge.chargeRecords : []).reduce((sum, c) => sum + (c.amount || 0), 0);
            const totalForgiven = (Array.isArray(pledge.forgivenRecords) ? pledge.forgivenRecords : []).reduce((sum, f) => sum + (f.amount || 0), 0);
            
            let totalOwed = totalCharges;
            
            if (pledge.schedule === 'recurring' && pledge.recurringDays) {
                // Recurring: add full amount each period (starts immediately, so +1 period)
                const daysSinceCreation = Math.floor((now - created) / (1000 * 60 * 60 * 24));
                const periods = Math.floor(daysSinceCreation / pledge.recurringDays) + 1; // +1 to start in debt
                totalOwed += (pledge.pledgedAmount || 0) * periods;
            } else if (pledge.schedule !== 'byDate' && !isNaN(parseInt(pledge.schedule))) {
                // "Over X days": starts with full amount immediately
                totalOwed += pledge.pledgedAmount || 0;
            } else {
                // By date: full amount due by target date (starts immediately in debt)
                totalOwed += pledge.pledgedAmount || 0;
            }
            
            return Math.max(0, totalOwed - totalPaid - totalForgiven);
        }

        // Get pledge status (safe, danger, overdue, completed)
        function getPledgeStatus(pledge) {
            const now = new Date();
            const created = new Date(pledge.createdAt);
            const totalPaid = (Array.isArray(pledge.payments) ? pledge.payments : []).reduce((sum, p) => sum + (p.amount || 0), 0);
            const totalForgiven = (Array.isArray(pledge.forgivenRecords) ? pledge.forgivenRecords : []).reduce((sum, f) => sum + (f.amount || 0), 0);
            
            if (pledge.schedule === 'recurring' && pledge.recurringDays) {
                const daysSinceCreation = Math.floor((now - created) / (1000 * 60 * 60 * 24));
                const periods = Math.floor(daysSinceCreation / pledge.recurringDays) + 1;
                const expectedPayment = (pledge.pledgedAmount || 0) * periods;
                const actualPayment = totalPaid + totalForgiven;
                const periodsPaid = Math.floor(actualPayment / (pledge.pledgedAmount || 0));
                const periodsMissed = periods - periodsPaid;
                
                if (actualPayment >= expectedPayment) return 'completed';
                if (periodsMissed >= 2) return 'overdue';
                if (periodsMissed >= 1) return 'danger';
                return 'safe';
            } else if (pledge.schedule !== 'byDate' && !isNaN(parseInt(pledge.schedule))) {
                // "Over X days" - use RPP
                const days = parseInt(pledge.schedule);
                const dailyAmount = (pledge.pledgedAmount || 0) / days;
                const daysSinceCreation = Math.floor((now - created) / (1000 * 60 * 60 * 24));
                const daysElapsed = Math.min(daysSinceCreation, days);
                const expectedPayment = dailyAmount * daysElapsed;
                const actualPayment = totalPaid + totalForgiven;
                
                if (actualPayment >= (pledge.pledgedAmount || 0)) return 'completed';
                if (daysSinceCreation >= days && actualPayment < (pledge.pledgedAmount || 0)) return 'overdue';
                if (actualPayment < expectedPayment * 0.5) return 'danger';
                return 'safe';
            } else {
                // By date
                const targetDate = new Date(pledge.targetDate);
                const actualPayment = totalPaid + totalForgiven;
                
                if (actualPayment >= (pledge.pledgedAmount || 0)) return 'completed';
                if (now > targetDate && actualPayment < (pledge.pledgedAmount || 0)) {
                    const daysPastDue = Math.floor((now - targetDate) / (1000 * 60 * 60 * 24));
                    if (daysPastDue >= 14) return 'overdue'; // 2 weeks past due
                    return 'danger';
                }
                if (now >= targetDate && actualPayment < (pledge.pledgedAmount || 0) * 0.5) return 'danger';
                return 'safe';
            }
        }

        // Get next debt increase date for pledge (accounting for payments)
        function getNextDebtIncreaseDate(pledge) {
            const now = new Date();
            const created = new Date(pledge.createdAt);
            const totalPaid = (Array.isArray(pledge.payments) ? pledge.payments : []).reduce((sum, p) => sum + (p.amount || 0), 0);
            const totalForgiven = (Array.isArray(pledge.forgivenRecords) ? pledge.forgivenRecords : []).reduce((sum, f) => sum + (f.amount || 0), 0);
            const totalAvailable = totalPaid + totalForgiven;
            
            if (pledge.schedule === 'recurring' && pledge.recurringDays) {
                const daysSinceCreation = Math.floor((now - created) / (1000 * 60 * 60 * 24));
                const periods = Math.floor(daysSinceCreation / pledge.recurringDays);
                const periodsPaid = Math.floor(totalAvailable / (pledge.pledgedAmount || 0));
                const nextPeriod = (periodsPaid + 1) * pledge.recurringDays;
                const nextDate = new Date(created);
                nextDate.setDate(nextDate.getDate() + nextPeriod);
                return nextDate;
            } else if (pledge.schedule !== 'byDate' && !isNaN(parseInt(pledge.schedule))) {
                const days = parseInt(pledge.schedule);
                const dailyAmount = (pledge.pledgedAmount || 0) / days;
                const daysPaid = Math.floor(totalAvailable / dailyAmount);
                const daysSinceCreation = Math.floor((now - created) / (1000 * 60 * 60 * 24));
                
                if (daysPaid < days && daysSinceCreation < days) {
                    const nextDate = new Date(created);
                    nextDate.setDate(nextDate.getDate() + daysPaid);
                    return nextDate;
                }
                return null; // All days passed or paid
            } else if (pledge.schedule === 'byDate' && pledge.targetDate) {
                return new Date(pledge.targetDate);
            }
            return null;
        }

        // Get next debt increase amount for pledge
        function getNextDebtIncreaseAmount(pledge) {
            if (pledge.schedule === 'recurring' && pledge.recurringDays) {
                return pledge.pledgedAmount || 0;
            } else if (pledge.schedule !== 'byDate' && !isNaN(parseInt(pledge.schedule))) {
                const days = parseInt(pledge.schedule);
                return (pledge.pledgedAmount || 0) / days; // Daily amount
            } else if (pledge.schedule === 'byDate' && pledge.targetDate) {
                const now = new Date();
                const targetDate = new Date(pledge.targetDate);
                if (now < targetDate) {
                    return pledge.pledgedAmount || 0; // Full amount on target date
                }
            }
            return 0;
        }

        async function loadPledges() {
            const pledges = await getPledges();
            const activePledges = pledges.filter(p => !p.completed);
            const container = document.getElementById('pledgesList');

            if (activePledges.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ü§ù</div><h3>No active pledges</h3><p>Add your first pledge to get started!</p></div>';
                return;
            }

            container.innerHTML = activePledges.map(pledge => {
                // Use RPP debt for "over X days" pledges, regular debt for others
                const rppDebt = pledge.schedule !== 'byDate' && !isNaN(parseInt(pledge.schedule)) ? calculateRPPDebt(pledge) : calculatePledgeDebt(pledge);
                const debt = calculatePledgeDebt(pledge);
                const status = getPledgeStatus(pledge);
                const totalPaid = (Array.isArray(pledge.payments) ? pledge.payments : []).reduce((sum, p) => sum + (p.amount || 0), 0);
                const totalCharges = (Array.isArray(pledge.chargeRecords) ? pledge.chargeRecords : []).reduce((sum, c) => sum + (c.amount || 0), 0);
                const totalForgiven = (Array.isArray(pledge.forgivenRecords) ? pledge.forgivenRecords : []).reduce((sum, f) => sum + (f.amount || 0), 0);
                const overallDebt = Math.max(0, (pledge.pledgedAmount || 0) - totalPaid - totalForgiven);
                
                let scheduleText = '';
                if (pledge.schedule === 'byDate') {
                    scheduleText = `By ${new Date(pledge.targetDate).toLocaleDateString()}`;
                } else if (pledge.schedule === 'recurring') {
                    const freqMap = { 1: 'Every Day', 7: 'Every Week', 14: 'Every 2 Weeks', 30: 'Every Month', 60: 'Every 2 Months', 90: 'Every 3 Months', 180: 'Every 6 Months', 365: 'Every Year' };
                    scheduleText = freqMap[pledge.recurringDays] || `Every ${pledge.recurringDays} days`;
                } else {
                    scheduleText = `Over ${pledge.schedule} days`;
                }

                // Determine badge text and style
                let badgeText = '';
                let badgeClass = '';
                const displayDebt = pledge.schedule !== 'byDate' && !isNaN(parseInt(pledge.schedule)) ? rppDebt : debt;
                
                if (displayDebt <= 0 && status !== 'completed') {
                    // Active but fully paid (not completed/canceled)
                    badgeText = 'Safe';
                    badgeClass = 'badge-success';
                } else if (status === 'completed') {
                    badgeText = 'Completed';
                    badgeClass = 'badge-success';
                } else if (status === 'overdue') {
                    badgeText = '$' + displayDebt.toFixed(2) + ' overdue';
                    badgeClass = 'badge-danger';
                } else if (status === 'danger') {
                    badgeText = '$' + displayDebt.toFixed(2) + ' owed';
                    badgeClass = 'badge-danger';
                } else {
                    badgeText = 'Safe';
                    badgeClass = 'badge-success';
                }

                // Card border style for danger/overdue
                const cardBorderStyle = status === 'danger' || status === 'overdue' ? 'border: 3px solid var(--danger);' : '';

                return `
                    <div class="card" style="${cardBorderStyle}">
                        <div class="card-header">
                            <div style="flex: 1; min-width: 0;">
                                <div class="card-title" style="word-break: break-word;">${pledge.name}</div>
                                ${pledge.phone ? `<div style="margin-top: 4px; color: var(--text-light); font-size: 0.9rem; word-break: break-word;">üìû ${pledge.phone}</div>` : ''}
                                ${status === 'danger' ? '<div style="margin-top: 4px; color: var(--danger); font-size: 0.85rem; font-weight: 600;">‚ö†Ô∏è In Danger</div>' : ''}
                                ${status === 'overdue' ? '<div style="margin-top: 4px; color: var(--danger); font-size: 0.85rem; font-weight: 600;">üö® Overdue</div>' : ''}
                            </div>
                            <div style="flex-shrink: 0;">
                                <span class="badge ${badgeClass}">${badgeText}</span>
                            </div>
                        </div>
                        <div class="card-body">
                            <div style="margin-bottom: 10px;">
                                <div><strong>Pledged Amount:</strong> $${pledge.pledgedAmount.toFixed(2)}</div>
                                <div><strong>Total Paid:</strong> $${totalPaid.toFixed(2)}</div>
                                ${totalCharges > 0 ? `<div><strong>Additional Charges:</strong> $${totalCharges.toFixed(2)}</div>` : ''}
                                ${totalForgiven > 0 ? `<div><strong>Total Forgiven:</strong> $${totalForgiven.toFixed(2)}</div>` : ''}
                                <div><strong>Schedule:</strong> ${scheduleText}</div>
                                ${pledge.schedule !== 'byDate' && !isNaN(parseInt(pledge.schedule)) && status !== 'overdue' ? (() => {
                                    const days = parseInt(pledge.schedule);
                                    const dailyAmount = (pledge.pledgedAmount || 0) / days;
                                    return `<div style="margin-top: 10px; padding: 10px; background: #f0f9ff; border-radius: 8px; border: 1px solid var(--primary);">
                                        <div style="font-weight: 600; color: var(--primary); margin-bottom: 5px;">üìã RPP (Recommended Payment Plan)</div>
                                        <div style="font-size: 0.9rem; margin-bottom: 5px;"><strong>Daily Payment:</strong> $${dailyAmount.toFixed(2)} per day over ${days} days</div>
                                        <div style="font-size: 0.9rem; font-weight: 600; color: var(--danger);"><strong>Overall Debt:</strong> $${overallDebt.toFixed(2)}</div>
                                    </div>`;
                                })() : ''}
                                ${status === 'overdue' && pledge.schedule !== 'byDate' && !isNaN(parseInt(pledge.schedule)) ? (() => {
                                    return `<div style="margin-top: 10px; padding: 10px; background: #fee2e2; border-radius: 8px; border: 2px solid var(--danger);">
                                        <div style="font-weight: 600; color: var(--danger); margin-bottom: 5px;">üö® Balance Needed</div>
                                        <div style="font-size: 0.9rem; font-weight: 600; color: var(--danger);"><strong>Amount to Pay:</strong> $${rppDebt.toFixed(2)}</div>
                                    </div>`;
                                })() : ''}
                                ${(() => {
                                    const nextDate = getNextDebtIncreaseDate(pledge);
                                    const increaseAmount = getNextDebtIncreaseAmount(pledge);
                                    if (nextDate && increaseAmount > 0) {
                                        return `<div style="margin-top: 5px; color: var(--warning); font-weight: 600;"><strong>Next debt increase:</strong> $${increaseAmount.toFixed(2)} on ${nextDate.toLocaleDateString()}</div>`;
                                    }
                                    return '';
                                })()}
                            </div>
                            <div style="margin-top: 10px;">
                                <button class="btn btn-primary" onclick="showPledgeYearView('${pledge.id}')" style="font-size: 0.9rem; padding: 8px 16px;">üìÜ Year View</button>
                            </div>
                            ${pledge.payments && pledge.payments.length > 0 ? 
                                '<div style="margin-top: 10px; font-size: 0.9rem;"><strong>Recent Payments:</strong><ul style="margin-top: 5px; padding-left: 20px;">' + 
                                pledge.payments.slice().reverse().slice(0, 3).map(p => {
                                    const date = new Date(p.date);
                                    const methodLabel = p.method ? ` (${p.method})` : '';
                                    return `<li>$${p.amount.toFixed(2)}${methodLabel} - ${date.toLocaleDateString()}</li>`;
                                }).join('') + '</ul></div>' : ''
                            }
                            <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                                <button class="btn btn-success" onclick="recordPledgePayment('${pledge.id}')" style="font-size: 0.9rem; padding: 8px 16px;">üíµ Record Payment</button>
                                <button class="btn btn-primary" onclick="addPledgeDebt('${pledge.id}')" style="font-size: 0.9rem; padding: 8px 16px;">‚ûï Add Debt</button>
                                <button class="btn btn-warning" onclick="forgivePledgeDebt('${pledge.id}')" style="font-size: 0.9rem; padding: 8px 16px;">‚úÖ Forgive Debt</button>
                                ${pledge.schedule === 'recurring' ? `<button class="btn btn-secondary" onclick="endPledge('${pledge.id}')" style="font-size: 0.9rem; padding: 8px 16px;">üèÅ End Pledge</button>` : ''}
                                <button class="btn btn-danger" onclick="deletePledge('${pledge.id}')" style="font-size: 0.9rem; padding: 8px 16px;">üóë Delete</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function deletePledge(pledgeId) {
            if (!confirm('Are you sure you want to delete this pledge?')) return;
            const pledges = await getPledges();
            const newPledges = pledges.filter(p => p.id !== pledgeId);
            await savePledges(newPledges);
            loadPledges();
            loadPledgeRecords();
        }

        // End Pledge (mark as completed)
        async function endPledge(pledgeId) {
            if (!confirm('Are you sure you want to end this pledge? It will be moved to records.')) return;
            const pledges = await getPledges();
            const pledge = pledges.find(p => p.id === pledgeId);
            if (!pledge) return;
            
            pledge.completed = true;
            pledge.completedDate = new Date().toISOString();
            
            await savePledges(pledges);
            loadPledges();
            loadPledgeRecords();
            showAlert('pledgeAlert', 'Pledge ended and moved to records!', 'success');
        }

        // Delete Pledge Record
        async function deletePledgeRecord(personName) {
            if (!confirm(`Are you sure you want to delete all pledge records for ${personName}? This cannot be undone.`)) return;
            const pledges = await getPledges();
            const newPledges = pledges.filter(p => p.name.toLowerCase() !== personName.toLowerCase() || !p.completed);
            await savePledges(newPledges);
            loadPledgeRecords();
            showAlert('pledgeAlert', 'Pledge records deleted!', 'success');
        }

        // Record Pledge Payment
        async function recordPledgePayment(pledgeId) {
            const pledges = await getPledges();
            const pledge = pledges.find(p => p.id === pledgeId);
            if (!pledge) return;

            const amountStr = prompt(`Record payment for ${pledge.name}\n\nAmount:`, '0');
            if (!amountStr || isNaN(amountStr) || parseFloat(amountStr) <= 0) return;
            const amount = parseFloat(amountStr);

            const method = prompt('Payment method (optional):', '');

            if (!Array.isArray(pledge.payments)) {
                pledge.payments = [];
            }

            pledge.payments.push({
                id: Date.now().toString(),
                amount: amount,
                method: method || '',
                date: new Date().toISOString()
            });

            // Check if completed (only if there was debt to begin with)
            const debt = calculatePledgeDebt(pledge);
            const now = new Date();
            const created = new Date(pledge.createdAt);
            
            const totalOwed = (() => {
                let owed = (Array.isArray(pledge.chargeRecords) ? pledge.chargeRecords : []).reduce((sum, c) => sum + (c.amount || 0), 0);
                
                if (pledge.schedule === 'recurring' && pledge.recurringDays) {
                    const daysSinceCreation = Math.floor((now - created) / (1000 * 60 * 60 * 24));
                    const periods = Math.floor(daysSinceCreation / pledge.recurringDays) + 1;
                    owed += (pledge.pledgedAmount || 0) * periods;
                } else if (pledge.schedule !== 'byDate' && !isNaN(parseInt(pledge.schedule))) {
                    // "Over X days": starts with full amount immediately
                    owed += pledge.pledgedAmount || 0;
                } else {
                    owed += pledge.pledgedAmount || 0;
                }
                return owed;
            })();
            
            // Only mark as completed if there was actual debt (> 0) and it's now fully paid off
            // Don't mark as completed if debt was 0 from the start (no time has passed yet)
            const hasTimePassed = (() => {
                if (pledge.schedule === 'recurring' && pledge.recurringDays) {
                    const daysSinceCreation = Math.floor((now - created) / (1000 * 60 * 60 * 24));
                    return daysSinceCreation >= pledge.recurringDays;
                } else if (pledge.schedule !== 'byDate' && !isNaN(parseInt(pledge.schedule))) {
                    const days = parseInt(pledge.schedule);
                    const daysSinceCreation = Math.floor((now - created) / (1000 * 60 * 60 * 24));
                    return daysSinceCreation > 0;
                } else if (pledge.schedule === 'byDate' && pledge.targetDate) {
                    return now >= new Date(pledge.targetDate);
                }
                return true; // By date defaults to true
            })();
            
            if (totalOwed > 0 && debt <= 0 && hasTimePassed) {
                pledge.completed = true;
                pledge.completedDate = new Date().toISOString();
            }

            await savePledges(pledges);
            loadPledges();
            loadPledgeRecords();
            showAlert('pledgeAlert', 'Payment recorded successfully!', 'success');
        }

        // Add Pledge Debt
        async function addPledgeDebt(pledgeId) {
            const pledges = await getPledges();
            const pledge = pledges.find(p => p.id === pledgeId);
            if (!pledge) return;

            const amountStr = prompt(`Add debt/charge for ${pledge.name}\n\nAmount:`, '0');
            if (!amountStr || isNaN(amountStr) || parseFloat(amountStr) <= 0) return;
            const amount = parseFloat(amountStr);

            const reason = prompt('Reason (optional):', '');

            if (!Array.isArray(pledge.chargeRecords)) {
                pledge.chargeRecords = [];
            }

            pledge.chargeRecords.push({
                id: Date.now().toString(),
                amount: amount,
                reason: reason || '',
                date: new Date().toISOString()
            });

            await savePledges(pledges);
            loadPledges();
            showAlert('pledgeAlert', 'Debt added successfully!', 'success');
        }

        // Forgive Pledge Debt
        async function forgivePledgeDebt(pledgeId) {
            const pledges = await getPledges();
            const pledge = pledges.find(p => p.id === pledgeId);
            if (!pledge) return;

            const debt = calculatePledgeDebt(pledge);
            if (debt <= 0) {
                alert('This pledge has no debt to forgive.');
                return;
            }

            const amountStr = prompt(`Forgive debt for ${pledge.name}\n\nCurrent debt: $${debt.toFixed(2)}\n\nAmount to forgive (default: full debt):`, debt.toFixed(2));
            if (!amountStr || isNaN(amountStr) || parseFloat(amountStr) <= 0) return;
            const amount = parseFloat(amountStr);

            const reason = prompt('Reason (optional):', '');

            if (!Array.isArray(pledge.forgivenRecords)) {
                pledge.forgivenRecords = [];
            }

            pledge.forgivenRecords.push({
                id: Date.now().toString(),
                amount: amount,
                reason: reason || '',
                date: new Date().toISOString()
            });

            // Check if completed - only if there was debt and it's now paid off
            const newDebt = calculatePledgeDebt(pledge);
            const now = new Date();
            const created = new Date(pledge.createdAt);
            const hasTimePassed = (() => {
                if (pledge.schedule === 'recurring' && pledge.recurringDays) {
                    const daysSinceCreation = Math.floor((now - created) / (1000 * 60 * 60 * 24));
                    return daysSinceCreation >= pledge.recurringDays;
                } else if (pledge.schedule !== 'byDate' && !isNaN(parseInt(pledge.schedule))) {
                    const days = parseInt(pledge.schedule);
                    const daysSinceCreation = Math.floor((now - created) / (1000 * 60 * 60 * 24));
                    return daysSinceCreation > 0;
                } else if (pledge.schedule === 'byDate' && pledge.targetDate) {
                    return now >= new Date(pledge.targetDate);
                }
                return true;
            })();
            
            // Only mark completed if there was actual debt and time has passed
            const hadDebt = debt > 0;
            if (hadDebt && newDebt <= 0 && hasTimePassed) {
                pledge.completed = true;
                pledge.completedDate = new Date().toISOString();
            }

            await savePledges(pledges);
            loadPledges();
            loadPledgeRecords();
            showAlert('pledgeAlert', 'Debt forgiven successfully!', 'success');
        }

        // Pledge Records
        let pledgeRecordSearchText = '';

        function onPledgeRecordSearchChange(e) {
            pledgeRecordSearchText = e.target.value.toLowerCase();
            loadPledgeRecords();
        }

        async function loadPledgeRecords() {
            const pledges = await getPledges();
            const completedPledges = pledges.filter(p => p.completed === true);
            const container = document.getElementById('pledgeRecordsList');

            const filtered = pledgeRecordSearchText
                ? completedPledges.filter(p => p.name.toLowerCase().includes(pledgeRecordSearchText))
                : completedPledges;

            if (filtered.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üìã</div><h3>No completed pledges yet</h3><p>Completed pledges will appear here.</p></div>';
                return;
            }

            // Group pledges by person name
            const grouped = {};
            filtered.forEach(pledge => {
                const name = pledge.name.toLowerCase();
                if (!grouped[name]) {
                    grouped[name] = [];
                }
                grouped[name].push(pledge);
            });

            container.innerHTML = Object.keys(grouped).map(personName => {
                const personPledges = grouped[personName];
                const firstPledge = personPledges[0];
                const totalPaid = personPledges.reduce((sum, p) => {
                    return sum + (Array.isArray(p.payments) ? p.payments : []).reduce((s, pay) => s + (pay.amount || 0), 0);
                }, 0);
                const totalPledged = personPledges.reduce((sum, p) => sum + (p.pledgedAmount || 0), 0);
                const totalCharges = personPledges.reduce((sum, p) => {
                    return sum + (Array.isArray(p.chargeRecords) ? p.chargeRecords : []).reduce((s, c) => s + (c.amount || 0), 0);
                }, 0);
                const totalForgiven = personPledges.reduce((sum, p) => {
                    return sum + (Array.isArray(p.forgivenRecords) ? p.forgivenRecords : []).reduce((s, f) => s + (f.amount || 0), 0);
                }, 0);

                // Combine all entries from all pledges
                const allEntries = [];
                personPledges.forEach(pledge => {
                    const payments = Array.isArray(pledge.payments) ? pledge.payments : [];
                    const forgiven = Array.isArray(pledge.forgivenRecords) ? pledge.forgivenRecords : [];
                    const charges = Array.isArray(pledge.chargeRecords) ? pledge.chargeRecords : [];
                    allEntries.push(...payments.map(p => ({ type: 'Payment', pledgeId: pledge.id, ...p })));
                    allEntries.push(...forgiven.map(f => ({ type: 'Forgiven', pledgeId: pledge.id, ...f })));
                    allEntries.push(...charges.map(c => ({ type: 'Debt Added', pledgeId: pledge.id, ...c })));
                });
                allEntries.sort((a, b) => new Date(b.date) - new Date(a.date));

                return `
                    <div class="card" style="border: 2px solid var(--primary);">
                        <div class="card-header">
                            <div>
                                <div class="card-title">${firstPledge.name} ${personPledges.length > 1 ? `(${personPledges.length} pledges)` : ''}</div>
                                ${firstPledge.phone ? `<div style="margin-top: 4px; color: var(--text-light); font-size: 0.9rem;">üìû ${firstPledge.phone}</div>` : ''}
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button class="btn btn-primary" onclick="downloadPledgePDF('${firstPledge.name}')" style="padding:8px 16px;font-size:0.9rem;">üì• Download PDF</button>
                                <button class="btn btn-danger" onclick="deletePledgeRecord('${firstPledge.name}')" style="padding:8px 16px;font-size:0.9rem;">üóë Delete</button>
                            </div>
                        </div>
                        <div class="card-body">
                            <div style="margin-bottom: 10px;">
                                <div><strong>Total Pledged:</strong> $${totalPledged.toFixed(2)}</div>
                                <div><strong>Total Paid:</strong> $${totalPaid.toFixed(2)}</div>
                                ${totalCharges > 0 ? `<div><strong>Additional Charges:</strong> $${totalCharges.toFixed(2)}</div>` : ''}
                                ${totalForgiven > 0 ? `<div><strong>Total Forgiven:</strong> $${totalForgiven.toFixed(2)}</div>` : ''}
                            </div>
                            ${personPledges.length > 1 ? 
                                '<div style="margin-top: 10px;"><strong>Pledges:</strong><ul style="margin-top: 5px; padding-left: 20px; font-size: 0.9rem;">' + 
                                personPledges.map(p => `<li>$${p.pledgedAmount.toFixed(2)} - Completed: ${new Date(p.completedDate).toLocaleDateString()}</li>`).join('') + 
                                '</ul></div>' : ''
                            }
                            ${allEntries.length > 0 ? 
                                '<div style="margin-top: 10px;"><strong>All Records:</strong><ul style="margin-top: 5px; padding-left: 20px; font-size: 0.9rem;">' + 
                                allEntries.map(entry => {
                                    const date = new Date(entry.date);
                                    let text = `${entry.type}: $${entry.amount.toFixed(2)} - ${date.toLocaleString()}`;
                                    if (entry.type === 'Payment' && entry.method) text += ` (Method: ${entry.method})`;
                                    if (entry.reason) text += ` (Reason: ${entry.reason})`;
                                    return `<li>${text}</li>`;
                                }).join('') + '</ul></div>' : 
                                '<p style="color: var(--text-light);">No records yet.</p>'
                            }
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Pledge Debt View
        let currentPledgeDebtIndex = 0;
        let pledgeDebtList = [];

        async function loadPledgeDebtView() {
            const pledges = await getPledges();
            pledgeDebtList = pledges.filter(p => {
                if (p.completed) return false;
                const debt = p.schedule !== 'byDate' && !isNaN(parseInt(p.schedule)) ? calculateRPPDebt(p) : calculatePledgeDebt(p);
                return debt > 0;
            });
            currentPledgeDebtIndex = 0;
            
            const container = document.getElementById('pledgeDebtViewer');
            
            if (pledgeDebtList.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üí∞</div>
                        <h3>No pledges in debt!</h3>
                        <p>All pledges are up to date.</p>
                    </div>
                `;
                return;
            }
            
            showPledgeDebt(0);
        }

        function showPledgeDebt(index) {
            if (index < 0 || index >= pledgeDebtList.length) return;
            
            currentPledgeDebtIndex = index;
            const pledge = pledgeDebtList[index];
            const debt = pledge.schedule !== 'byDate' && !isNaN(parseInt(pledge.schedule)) ? calculateRPPDebt(pledge) : calculatePledgeDebt(pledge);
            const totalPaid = (Array.isArray(pledge.payments) ? pledge.payments : []).reduce((sum, p) => sum + (p.amount || 0), 0);
            const nextDate = getNextDebtIncreaseDate(pledge);
            const increaseAmount = getNextDebtIncreaseAmount(pledge);
            
            let scheduleText = '';
            if (pledge.schedule === 'byDate') {
                scheduleText = `By ${new Date(pledge.targetDate).toLocaleDateString()}`;
            } else if (pledge.schedule === 'recurring') {
                const freqMap = { 1: 'Every Day', 7: 'Every Week', 14: 'Every 2 Weeks', 30: 'Every Month', 60: 'Every 2 Months', 90: 'Every 3 Months', 180: 'Every 6 Months', 365: 'Every Year' };
                scheduleText = freqMap[pledge.recurringDays] || `Every ${pledge.recurringDays} days`;
            } else {
                scheduleText = `Over ${pledge.schedule} days`;
            }
            
            const container = document.getElementById('pledgeDebtViewer');
            container.innerHTML = `
                <div class="debt-student-card">
                    <div style="margin-bottom: 20px;">
                        <span class="badge badge-danger" style="font-size: 1rem; padding: 8px 16px;">Pledge ${index + 1} of ${pledgeDebtList.length}</span>
                    </div>
                    <div class="debt-student-name">${pledge.name}</div>
                    <div class="debt-amount">$${debt.toFixed(2)}</div>
                    <div class="debt-info">
                        <div class="debt-info-item">
                            <div class="debt-info-label">Pledged Amount</div>
                            <div class="debt-info-value">$${pledge.pledgedAmount.toFixed(2)}</div>
                        </div>
                        <div class="debt-info-item">
                            <div class="debt-info-label">Total Paid</div>
                            <div class="debt-info-value">$${totalPaid.toFixed(2)}</div>
                        </div>
                        <div class="debt-info-item">
                            <div class="debt-info-label">Schedule</div>
                            <div class="debt-info-value">${scheduleText}</div>
                        </div>
                        <div class="debt-info-item">
                            <div class="debt-info-label">${nextDate ? 'Next Debt Increase' : 'Status'}</div>
                            <div class="debt-info-value">${nextDate && increaseAmount > 0 ? `$${increaseAmount.toFixed(2)} on ${nextDate.toLocaleDateString()}` : nextDate ? nextDate.toLocaleDateString() : 'Completed'}</div>
                        </div>
                    </div>
                    <div class="navigation-buttons">
                        <button class="btn btn-primary" onclick="navigatePledgeDebt(-1)" ${index === 0 ? 'disabled style="opacity: 0.5;"' : ''}>‚Üê Previous</button>
                        <button class="btn btn-success" onclick="recordPledgePayment('${pledge.id}')">Record Payment</button>
                        <button class="btn btn-primary" onclick="navigatePledgeDebt(1)" ${index === pledgeDebtList.length - 1 ? 'disabled style="opacity: 0.5;"' : ''}>Next ‚Üí</button>
                    </div>
                </div>
            `;
        }

        function navigatePledgeDebt(direction) {
            const newIndex = currentPledgeDebtIndex + direction;
            if (newIndex >= 0 && newIndex < pledgeDebtList.length) {
                showPledgeDebt(newIndex);
            }
        }

        // Pledge Year View
        let selectedPledgeForYear = null;
        let selectedYearForPledge = new Date().getFullYear();

        async function showPledgeYearView(pledgeId) {
            const pledges = await getPledges();
            const pledge = pledges.find(p => p.id === pledgeId);
            if (!pledge) return;
            
            selectedPledgeForYear = pledgeId;
            selectedYearForPledge = new Date().getFullYear();
            renderPledgeYearPanel(pledge);
        }

        function renderPledgeYearPanel(pledge) {
            const panel = document.getElementById('pledgeYearPanel');
            if (!panel) return;
            
            const year = selectedYearForPledge;
            let viewScale = 'year';
            let cells = [];
            
            if (pledge.schedule === 'recurring' && pledge.recurringDays) {
                if (pledge.recurringDays === 7) {
                    // Weekly payments - show weeks
                    viewScale = 'weeks';
                    const created = new Date(pledge.createdAt);
                    const yearStart = new Date(year, 0, 1);
                    const yearEnd = new Date(year, 11, 31);
                    
                    // Find first week of year that includes or is after creation date
                    let currentWeek = new Date(yearStart);
                    const dayOfWeek = currentWeek.getDay();
                    currentWeek.setDate(currentWeek.getDate() - dayOfWeek); // Start of week (Sunday)
                    
                    let weekNum = 1;
                    while (currentWeek <= yearEnd && weekNum <= 52) {
                        const weekEnd = new Date(currentWeek);
                        weekEnd.setDate(weekEnd.getDate() + 6);
                        
                        // Check if this week overlaps with pledge period
                        if (currentWeek <= yearEnd && weekEnd >= yearStart) {
                            const isPaid = checkPledgeWeekPaid(pledge, currentWeek, weekEnd);
                            cells.push({ 
                                date: currentWeek, 
                                paid: isPaid, 
                                label: `Week ${weekNum}`,
                                endDate: weekEnd
                            });
                        }
                        
                        currentWeek.setDate(currentWeek.getDate() + 7);
                        weekNum++;
                    }
                } else if (pledge.recurringDays <= 7) {
                    // Daily or less frequent - show days of current month
                    viewScale = 'month';
                    const month = new Date().getMonth();
                    const daysInMonth = new Date(year, month + 1, 0).getDate();
                    for (let i = 1; i <= daysInMonth; i++) {
                        const cellDate = new Date(year, month, i);
                        const isPaid = checkPledgeDatePaid(pledge, cellDate);
                        cells.push({ date: cellDate, paid: isPaid, label: i.toString() });
                    }
                } else {
                    // Monthly or longer - show months
                    viewScale = 'year';
                    for (let i = 0; i < 12; i++) {
                        const monthDate = new Date(year, i, 1);
                        const isPaid = checkPledgeMonthPaid(pledge, year, i);
                        cells.push({ date: monthDate, paid: isPaid, label: MONTH_NAMES[i] });
                    }
                }
            } else if (pledge.schedule !== 'byDate' && !isNaN(parseInt(pledge.schedule))) {
                const days = parseInt(pledge.schedule);
                const created = new Date(pledge.createdAt);
                const pledgeEnd = new Date(created);
                pledgeEnd.setDate(pledgeEnd.getDate() + days);
                const dailyAmount = (pledge.pledgedAmount || 0) / days;
                
                // Calculate total paid and forgiven
                const totalPaid = (Array.isArray(pledge.payments) ? pledge.payments : []).reduce((sum, p) => sum + (p.amount || 0), 0);
                const totalForgiven = (Array.isArray(pledge.forgivenRecords) ? pledge.forgivenRecords : []).reduce((sum, f) => sum + (f.amount || 0), 0);
                const totalAvailable = totalPaid + totalForgiven;
                
                // Calculate how many days are paid based on RPP
                const daysPaid = Math.floor(totalAvailable / dailyAmount);
                
                // Show all days up to the pledge duration
                for (let i = 0; i < days; i++) {
                    const cellDate = new Date(created);
                    cellDate.setDate(cellDate.getDate() + i);
                    if (cellDate > pledgeEnd) break;
                    // Mark as paid if within the paid days range
                    const isPaid = (i < daysPaid);
                    cells.push({ date: cellDate, paid: isPaid, label: (i + 1).toString() });
                }
            } else {
                for (let i = 0; i < 12; i++) {
                    const monthDate = new Date(year, i, 1);
                    const isPaid = checkPledgeMonthPaid(pledge, year, i);
                    cells.push({ date: monthDate, paid: isPaid, label: MONTH_NAMES[i] });
                }
            }
            
            const cellsHtml = cells.map(cell => {
                const statusClass = cell.paid ? 'month-paid' : 'month-unpaid';
                return `
                    <div class="month-cell ${statusClass}">
                        <div class="month-name">${cell.label}</div>
                        <div class="month-status">${cell.paid ? 'Paid' : 'Not Paid'}</div>
                    </div>
                `;
            }).join('');
            
            panel.style.display = 'block';
            panel.innerHTML = `
                <div class="year-panel-header">
                    <div><strong>${pledge.name}</strong> ‚Äì Pledge Payment View</div>
                    <button class="btn btn-danger" style="padding:6px 10px;font-size:0.8rem;" onclick="document.getElementById('pledgeYearPanel').style.display='none'">Close</button>
                </div>
                <div class="year-selector">
                    <button type="button" onclick="changePledgeYear(-1)">‚Üê Previous</button>
                    <div class="year-label">${year}</div>
                    <button type="button" onclick="changePledgeYear(1)">Next ‚Üí</button>
                </div>
                <div class="month-grid">
                    ${cellsHtml}
                </div>
            `;
        }

        async function changePledgeYear(delta) {
            if (!selectedPledgeForYear) return;
            selectedYearForPledge += delta;
            const pledges = await getPledges();
            const pledge = pledges.find(p => p.id === selectedPledgeForYear);
            if (pledge) renderPledgeYearPanel(pledge);
        }

        function checkPledgeDatePaid(pledge, date) {
            const payments = Array.isArray(pledge.payments) ? pledge.payments : [];
            const dateStr = date.toISOString().split('T')[0];
            return payments.some(p => {
                const paymentDate = new Date(p.date).toISOString().split('T')[0];
                return paymentDate === dateStr;
            });
        }

        function checkPledgeWeekPaid(pledge, weekStart, weekEnd) {
            const created = new Date(pledge.createdAt);
            const now = new Date();
            
            // Check if this week is within the pledge period
            if (weekStart < created || weekEnd > now) return false;
            
            // For recurring weekly, check if payments cover this week's period
            if (pledge.schedule === 'recurring' && pledge.recurringDays === 7) {
                const payments = Array.isArray(pledge.payments) ? pledge.payments : [];
                const totalPaid = payments.reduce((sum, p) => sum + (p.amount || 0), 0);
                
                // Calculate expected debt for this week
                const daysSinceCreation = Math.floor((weekEnd - created) / (1000 * 60 * 60 * 24));
                const periods = Math.floor(daysSinceCreation / 7) + 1;
                const expectedDebt = (pledge.pledgedAmount || 0) * periods;
                
                // Check if payments cover this period
                const totalCharges = (Array.isArray(pledge.chargeRecords) ? pledge.chargeRecords : []).reduce((sum, c) => sum + (c.amount || 0), 0);
                const totalForgiven = (Array.isArray(pledge.forgivenRecords) ? pledge.forgivenRecords : []).reduce((sum, f) => sum + (f.amount || 0), 0);
                
                return totalPaid + totalForgiven >= expectedDebt - totalCharges;
            }
            
            return false;
        }

        function checkPledgeMonthPaid(pledge, year, month) {
            const payments = Array.isArray(pledge.payments) ? pledge.payments : [];
            return payments.some(p => {
                const paymentDate = new Date(p.date);
                return paymentDate.getFullYear() === year && paymentDate.getMonth() === month;
            });
        }

        // Download Pledge PDF
        async function downloadPledgePDF(personName) {
            const pledges = await getPledges();
            const personPledges = pledges.filter(p => p.name.toLowerCase() === personName.toLowerCase() && p.completed === true);
            
            if (personPledges.length === 0) {
                alert('No completed pledges found for this person.');
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            const totalPaid = personPledges.reduce((sum, p) => {
                return sum + (Array.isArray(p.payments) ? p.payments : []).reduce((s, pay) => s + (pay.amount || 0), 0);
            }, 0);
            const totalPledged = personPledges.reduce((sum, p) => sum + (p.pledgedAmount || 0), 0);
            const totalCharges = personPledges.reduce((sum, p) => {
                return sum + (Array.isArray(p.chargeRecords) ? p.chargeRecords : []).reduce((s, c) => s + (c.amount || 0), 0);
            }, 0);
            const totalForgiven = personPledges.reduce((sum, p) => {
                return sum + (Array.isArray(p.forgivenRecords) ? p.forgivenRecords : []).reduce((s, f) => s + (f.amount || 0), 0);
            }, 0);

            let y = 20;
            doc.setFontSize(18);
            doc.text(`Pledge Records: ${personPledges[0].name}`, 14, y);
            y += 10;
            if (personPledges[0].phone) {
                doc.setFontSize(10);
                doc.text(`Phone: ${personPledges[0].phone}`, 14, y);
                y += 7;
            }
            if (personPledges.length > 1) {
                doc.setFontSize(10);
                doc.text(`Total Pledges: ${personPledges.length}`, 14, y);
                y += 7;
            }
            y += 5;

            doc.setFontSize(12);
            doc.text(`Total Pledged: $${totalPledged.toFixed(2)}`, 14, y);
            y += 7;
            doc.text(`Total Paid: $${totalPaid.toFixed(2)}`, 14, y);
            y += 7;
            if (totalCharges > 0) {
                doc.text(`Additional Charges: $${totalCharges.toFixed(2)}`, 14, y);
                y += 7;
            }
            if (totalForgiven > 0) {
                doc.text(`Total Forgiven: $${totalForgiven.toFixed(2)}`, 14, y);
                y += 7;
            }
            y += 10;

            // Combine all entries
            const allEntries = [];
            personPledges.forEach(pledge => {
                const payments = Array.isArray(pledge.payments) ? pledge.payments : [];
                const forgiven = Array.isArray(pledge.forgivenRecords) ? pledge.forgivenRecords : [];
                const charges = Array.isArray(pledge.chargeRecords) ? pledge.chargeRecords : [];
                allEntries.push(...payments.map(p => ({ type: 'Payment', pledgeAmount: pledge.pledgedAmount, ...p })));
                allEntries.push(...forgiven.map(f => ({ type: 'Forgiven', pledgeAmount: pledge.pledgedAmount, ...f })));
                allEntries.push(...charges.map(c => ({ type: 'Debt Added', pledgeAmount: pledge.pledgedAmount, ...c })));
            });
            allEntries.sort((a, b) => new Date(b.date) - new Date(a.date));

            if (allEntries.length > 0) {
                doc.text('Transaction History:', 14, y);
                y += 7;
                doc.setFontSize(10);
                allEntries.forEach(entry => {
                    if (y > 280) {
                        doc.addPage();
                        y = 20;
                    }
                    const date = new Date(entry.date);
                    let text = `${entry.type}: $${entry.amount.toFixed(2)} - ${date.toLocaleString()}`;
                    if (entry.type === 'Payment' && entry.method) text += ` (Method: ${entry.method})`;
                    if (entry.reason) text += ` (Reason: ${entry.reason})`;
                    doc.text(text, 14, y);
                    y += 6;
                });
            }

            // Add date generated
            y += 10;
            doc.setFontSize(8);
            doc.setTextColor(128, 128, 128);
            doc.text(`Report generated: ${new Date().toLocaleString()}`, 14, y);

            doc.save(`${personPledges[0].name}_PledgeRecords.pdf`);
        }

        // Initialize
        window.onload = function() {
            loadDashboard();
        };
    </script>
</body>
</html>
